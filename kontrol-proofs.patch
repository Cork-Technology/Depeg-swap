diff --git a/contracts/libraries/VaultLib.sol b/contracts/libraries/VaultLib.sol
index e3c1615..54e4d27 100644
--- a/contracts/libraries/VaultLib.sol
+++ b/contracts/libraries/VaultLib.sol
@@ -368,7 +368,7 @@ library VaultLibrary {
         uint256 dsId,
         uint256 amount,
         IDsFlashSwapCore flashSwapRouter
-    ) internal returns (uint256 received) {
+    ) internal view returns (uint256 received) {
         Id id = self.info.toId();
         address ct = self.ds[dsId].ct;
         MarketSnapshot memory snapshot = ammRouter.getMarketSnapshot(self.info.ra, ct);
diff --git a/cork-lemmas.k b/cork-lemmas.k
new file mode 100644
index 0000000..45481cf
--- /dev/null
+++ b/cork-lemmas.k
@@ -0,0 +1,121 @@
+requires "evm.md"
+requires "foundry.md"
+// requires "keccak.md"
+
+module CORK-LEMMAS
+    imports EVM
+    imports FOUNDRY
+    imports INT-SYMBOLIC
+    imports MAP-SYMBOLIC
+    imports SET-SYMBOLIC
+
+    syntax StepSort ::= Int
+                      | Bool
+                      | Bytes
+                      | Map
+                      | Set
+ // -------------------------
+
+    syntax KItem ::= runLemma ( StepSort )
+                   | doneLemma( StepSort )
+ // --------------------------------------
+    rule <k> runLemma(T) => doneLemma(T) ... </k>
+
+    //
+    //  Arithmetic
+    //
+    rule C <=Int A *Int B => C /Int A <=Int B
+      requires 0 <=Int C andBool 0 <Int A
+       andBool C modInt A ==Int 0
+       [simplification(40), concrete(C, A), preserves-definedness]
+
+    rule A ==Int B => false
+      requires 0 <=Int A andBool B <Int 0
+      [simplification, concrete(B)]
+
+    rule 0 <=Int A -Int B => B <=Int A
+      [simplification, symbolic(A, B)]
+
+    rule (A *Int (B *Int C)) => (A *Int B) *Int C
+      [simplification, concrete(A, B)]
+
+    rule (A *Int B) /Int C => ((A /Int 10) *Int B) /Int (C /Int 10)
+      requires notBool (C ==Int 0) andBool A modInt 10 ==Int 0 andBool C modInt 10 ==Int 0
+      [simplification, concrete(A, C), preserves-definedness]
+
+    rule A /Int (B *Int C) => (A /Int 10) /Int ((B /Int 10) *Int C)
+      requires notBool (B ==Int 0) andBool notBool (C ==Int 0)
+       andBool A modInt 10 ==Int 0 andBool B modInt 10 ==Int 0
+      [simplification, concrete(A, B), preserves-definedness]
+
+    // Instantiation of the Kontrol lemma
+    // rule ( X ==Int ( X *Int Y ) /Word Y ) orBool Y ==Int 0 => true [simplification, preserves-definedness]
+    // when Y is of the form Y *Int Z, because then the `Y ==Int 0` condition gets simplified to a different form
+    rule ( X ==Int ( X *Int (Y *Int Z) ) /Word (Y *Int Z) ) orBool (Y ==Int 0 orBool Z ==Int 0) => true [simplification, preserves-definedness]
+
+    // Instantiation of the Kontrol lemma
+    // rule ( X ==Int ( X *Int Y ) /Word Y ) orBool Y ==Int 0 => true [simplification, preserves-definedness]
+    // when Y is of the form Y *Int ( Z *Int T ), because then the `Y ==Int 0` condition gets simplified to a different form
+    rule ( X ==Int ( X *Int (Y *Int (Z *Int T)) ) /Word (Y *Int (Z *Int T)) ) orBool (Y ==Int 0 orBool (Z ==Int 0 orBool T ==Int 0)) => true [simplification, preserves-definedness]
+
+    // Instantiation of the Kontrol lemma
+    // rule ( X ==Int ( X *Int Y ) /Word Y ) orBool Y ==Int 0 => true [simplification, preserves-definedness]
+    // when Y is of the form Y /Int Z, because then the `Y ==Int 0` condition gets simplified to a different form
+    rule ( X ==Int ( X *Int (Y /Int Z) ) /Word (Y /Int Z) ) orBool Y <Int Z => true
+      requires notBool ( Z ==Int 0 )
+      [simplification, preserves-definedness]
+
+    rule [chop-sub]:
+      chop ( Y -Int X:Int ) ==Int 0 => X ==Int Y
+      requires #rangeUInt(256, X) andBool #rangeUInt(256, Y)
+      [simplification, concrete(Y), comm]
+
+    rule [keccak-slots-disjoint]:
+      keccak ( A ) ==Int keccak ( B ) +Int C => false
+      requires notBool 0 ==Int C
+      [simplification, concrete(C), comm]
+
+    rule [keccak-slots-disjoint-ml-l]:
+      { keccak ( A ) #Equals keccak ( B ) +Int C } => #Bottom
+      requires notBool 0 ==Int C
+      [simplification, concrete(C)]
+
+    rule [keccak-slots-disjoint-ml-r]:
+      { keccak ( B ) +Int C #Equals keccak ( A ) } => #Bottom
+      requires notBool 0 ==Int C
+      [simplification, concrete(C)]
+
+    rule ( SetItem(X:Int) S:Set ) |Set SetItem(Y:Int) => SetItem(X) ( S |Set SetItem (Y) ) requires notBool X ==Int Y [simplification, preserves-definedness]
+    rule ( SetItem(X:Int) S:Set ) |Set SetItem(Y:Int) => SetItem(X) S                      requires         X ==Int Y [simplification, preserves-definedness]
+    rule                     .Set |Set SetItem(X:Int) => SetItem(X)                                                   [simplification, preserves-definedness]
+
+    rule K1 in_keys((K2 |-> _ ) M) => K1 ==Int K2 orBool K1 in_keys(M) [simplification]
+
+    rule [transferFunds-hp-neq]:
+      <k> #transferFunds ACCTFROM ACCTTO VALUE => .K ... </k>
+      <account>
+        <acctID> ACCTFROM </acctID>
+        <balance> ORIGFROM => ORIGFROM -Word VALUE </balance>
+        ...
+      </account>
+      <account>
+        <acctID> ACCTTO </acctID>
+        <balance> ORIGTO => ORIGTO +Word VALUE </balance>
+        ...
+      </account>
+      requires ACCTFROM =/=K ACCTTO andBool VALUE <=Int ORIGFROM
+      [priority(30), preserves-definedness]
+
+    rule [accounts-in-keys]:
+      `AccountCellMap:in_keys`(
+        <acctID> (X:Int) </acctID>,
+        (`_AccountCellMap_`(AccountCellMapItem(<acctID> Y:Int </acctID>, _:AccountCell):AccountCellMap, ACCOUNTS_REST:AccountCellMap)):AccountCellMap
+      ) => X ==Int Y orBool `AccountCellMap:in_keys`(<acctID> (X:Int) </acctID>, ACCOUNTS_REST)
+      [simplification, preserves-definedness]
+
+endmodule
+
+module CORK-LEMMAS-SPEC
+    imports CORK-LEMMAS
+
+endmodule
\ No newline at end of file
diff --git a/foundry.toml b/foundry.toml
index 8f50f98..ba36dda 100644
--- a/foundry.toml
+++ b/foundry.toml
@@ -9,4 +9,18 @@ ffi = true
 optimizer = true
 optimizer_runs = 200
 solc_version = "0.8.26"
-fs_permissions = [{ access = "read", path = "./"}]
\ No newline at end of file
+fs_permissions = [{ access = "read", path = "./"}]
+
+[profile.kontrol-properties]
+src = "contracts"
+evm_version = "cancun"
+out = "out"
+libs = ["node_modules","lib"]
+test = "test/forge/kontrol"
+cache_path = "cache_forge"
+ffi = true
+optimizer = true
+optimizer_runs = 200
+solc_version = "0.8.26"
+fs_permissions = [{ access = "read", path = "./"}]
+ast = true
\ No newline at end of file
diff --git a/kontrol.toml b/kontrol.toml
new file mode 100644
index 0000000..d31f090
--- /dev/null
+++ b/kontrol.toml
@@ -0,0 +1,65 @@
+[build.default]
+foundry-project-root       = '.'
+regen                      = true
+rekompile                  = true
+verbose                    = false
+debug                      = false
+require                    = 'cork-lemmas.k'
+module-import              = 'TestBase:CORK-LEMMAS'
+auxiliary-lemmas           = true
+o2                         = true
+
+[prove.default]
+schedule                   = 'CANCUN'
+foundry-project-root       = '.'
+verbose                    = false
+debug                      = false
+max-depth                  = 100000
+max-iterations             = 10000
+reinit                     = false
+cse                        = false
+workers                    = 4
+max-frontier-parallel      = 3
+maintenance-rate           = 100
+assume-defined             = true
+no-log-succ-rewrites = true
+no-stack-checks            = true
+kore-rpc-command           = 'kore-rpc-booster --no-post-exec-simplify --equation-max-recursion 100 --equation-max-iterations 1000'
+failure-information        = true
+counterexample-information = true
+minimize-proofs            = false
+fail-fast                  = true
+smt-timeout                = 16000
+smt-retry-limit            = 0
+break-every-step           = false
+break-on-jumpi             = false
+break-on-calls             = false
+break-on-storage           = false
+break-on-basic-blocks      = false
+break-on-cheatcodes        = false
+run-constructor            = false
+symbolic-immutables        = true
+match-test                 = [
+        "PsmTest.test_reinitialize_fail",
+        "PsmTest.test_deposit_PSM_correctness",
+        "PsmTest.test_redeemRaWithDs_correctness",
+        "LiquidityVaultTest.test_depositLV_revert_after_expiry",
+        "LiquidityVaultTest.test_depositLV_correctness",
+        "LiquidityVaultTest.test_redeemLV_correctness",
+        "MathHelperTest.testCalculatePercentageFee",
+        "MathHelperTest.testCalculateProvideLiquidityAmountBasedOnCtPrice",
+        "MathHelperTest.testCalculateRedeemLv",
+        "MathHelperTest.testCalculateEqualSwapAmount",
+        "RouterTest.test_swapRaForDs_rollover",
+        "RouterTest.test_swapDsForRa"
+    ]
+
+[show.default]
+foundry-project-root       = '.'
+verbose                    = false
+debug                      = false
+use-hex-encoding           = false
+
+[view-kcfg.default]
+foundry-project-root       = '.'
+use-hex-encoding           = false
\ No newline at end of file
diff --git a/lib/kontrol-cheatcodes b/lib/kontrol-cheatcodes
new file mode 160000
index 0000000..cb50e05
--- /dev/null
+++ b/lib/kontrol-cheatcodes
@@ -0,0 +1 @@
+Subproject commit cb50e05865124010ce7006db46946b8b8ec059e2
diff --git a/lib/v4-periphery b/lib/v4-periphery
new file mode 160000
index 0000000..d767807
--- /dev/null
+++ b/lib/v4-periphery
@@ -0,0 +1 @@
+Subproject commit d767807d357b18bb8d35876b52c0556f1c2b302f
diff --git a/test/forge/kontrol/Constants.k.sol b/test/forge/kontrol/Constants.k.sol
new file mode 100644
index 0000000..a8e855e
--- /dev/null
+++ b/test/forge/kontrol/Constants.k.sol
@@ -0,0 +1,5 @@
+// SPDX-License-Identifier: UNLICENSED
+pragma solidity ^0.8.24;
+
+uint256 constant ETH_UPPER_BOUND = 2 ** 95;
+uint256 constant TIME_UPPER_BOUND = 2 ** 35;
\ No newline at end of file
diff --git a/test/forge/kontrol/KontrolTest.k.sol b/test/forge/kontrol/KontrolTest.k.sol
new file mode 100644
index 0000000..d3215b7
--- /dev/null
+++ b/test/forge/kontrol/KontrolTest.k.sol
@@ -0,0 +1,125 @@
+pragma solidity ^0.8.24;
+
+import "forge-std/Vm.sol";
+import "forge-std/Test.sol";
+
+import "./Constants.k.sol";
+import {KontrolCheats} from "lib/kontrol-cheatcodes/src/KontrolCheats.sol";
+
+contract KontrolTest is Test, KontrolCheats {
+    // Note: there are lemmas dependent on `ethUpperBound`
+    uint256 constant ethMaxWidth = 96;
+    uint256 constant ethUpperBound = 2 ** ethMaxWidth;
+    // Note: 2 ** 35 takes us to year 3058
+    uint256 constant timeUpperBound = 2 ** 35;
+
+    function infoAssert(bool condition, string memory message) external pure {
+        if (!condition) {
+            revert(message);
+        }
+    }
+
+    enum Mode {
+        Assume,
+        Try,
+        Assert
+    }
+
+    function _establish(Mode mode, bool condition) internal pure returns (bool) {
+        if (mode == Mode.Assume) {
+            vm.assume(condition);
+            return true;
+        } else if (mode == Mode.Try) {
+            return condition;
+        } else {
+            assert(condition);
+            return true;
+        }
+    }
+
+    function freshUInt256Bounded() internal view returns (uint256) {
+        uint256 fresh = freshUInt256();
+        vm.assume(fresh < ETH_UPPER_BOUND);
+        return fresh;
+    }
+
+    function freshUInt256Bounded(string memory varName) internal returns (uint256) {
+        uint256 fresh = kevm.freshUInt(32, varName);
+        vm.assume(fresh < ETH_UPPER_BOUND);
+        return fresh;
+    }
+
+    function _loadData(
+        address contractAddress,
+        uint256 slot,
+        uint256 offset,
+        uint256 width
+    ) internal view returns (uint256) {
+        // `offset` and `width` must not overflow the slot
+        assert(offset + width <= 32);
+
+        // Slot read mask
+        uint256 mask;
+        unchecked {
+            mask = (2 ** (8 * width)) - 1;
+        }
+        // Value right shift
+        uint256 shift = 8 * offset;
+
+        // Current slot value
+        uint256 slotValue = uint256(vm.load(contractAddress, bytes32(slot)));
+
+        // Isolate and return data to retrieve
+        return mask & (slotValue >> shift);
+    }
+
+    function _storeData(address contractAddress, uint256 slot, uint256 offset, uint256 width, uint256 value) internal {
+        // `offset` and `width` must not overflow the slot
+        assert(offset + width <= 32);
+        // and `value` must fit into the designated part
+        assert(width == 32 || value < 2 ** (8 * width));
+
+        // Slot update mask
+        uint256 maskLeft;
+        unchecked {
+            maskLeft = ~((2 ** (8 * (offset + width))) - 1);
+        }
+        uint256 maskRight = (2 ** (8 * offset)) - 1;
+        uint256 mask = maskLeft | maskRight;
+
+        value = (2 ** (8 * offset)) * value;
+
+        // Current slot value
+        uint256 slotValue = uint256(vm.load(contractAddress, bytes32(slot)));
+        // Updated slot value
+        slotValue = value | (mask & slotValue);
+
+        vm.store(contractAddress, bytes32(slot), bytes32(slotValue));
+    }
+
+    function _loadUInt256(address contractAddress, uint256 slot) internal view returns (uint256) {
+        return _loadData(contractAddress, slot, 0, 32);
+    }
+
+    function _loadAddress(address contractAddress, uint256 slot) internal view returns (address) {
+        return address(uint160(_loadData(contractAddress, slot, 0, 20)));
+    }
+
+    function _storeUInt256(address contractAddress, uint256 slot, uint256 value) internal {
+        _storeData(contractAddress, slot, 0, 32, value);
+    }
+
+    function _storeAddress(address contractAddress, uint256 slot, address value) internal {
+        _storeData(contractAddress, slot, 0, 20, uint160(value));
+    }
+
+    function _storeBytes32(address contractAddress, uint256 slot, bytes32 value) internal {
+        _storeUInt256(contractAddress, slot, uint256(value));
+    }
+
+    function _assumeNoOverflow(uint256 augend, uint256 addend) internal pure {
+        unchecked {
+            vm.assume(augend < augend + addend);
+        }
+    }
+}
\ No newline at end of file
diff --git a/test/forge/kontrol/LiquidityVaultTest.k.sol b/test/forge/kontrol/LiquidityVaultTest.k.sol
new file mode 100644
index 0000000..f9854d5
--- /dev/null
+++ b/test/forge/kontrol/LiquidityVaultTest.k.sol
@@ -0,0 +1,316 @@
+pragma solidity ^0.8.24;
+
+import {ModuleCoreTest} from "./ModuleCoreTest.k.sol";
+import {TestCorkHook} from "./TestCorkHook.k.sol";
+
+import {Id, Pair}        from "../../../contracts/libraries/Pair.sol";
+import {Guard}     from "../../../contracts/libraries/Guard.sol";
+import {DepegSwap} from "../../../contracts/libraries/DepegSwapLib.sol";
+import {MathHelper} from "../../../contracts/libraries/MathHelper.sol";
+import {IVault} from "../../../contracts/interfaces/IVault.sol";
+import {Withdrawal} from "../../../contracts/core/Withdrawal.sol";
+
+import {RouterState} from "../../../contracts/core/flash-swaps/FlashSwapRouter.sol";
+import {TestAsset}     from "./TestAsset.k.sol";
+import {TestERC20} from "./TestERC20.t.sol";
+
+import {SafeERC20, IERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
+import {MarketSnapshot} from "Cork-Hook/lib/MarketSnapshot.sol";
+import {ICorkHook} from "Cork-Hook/interfaces/ICorkHook.sol";
+
+import "./Constants.k.sol";
+
+struct ProofState {
+    uint256 lvTotalSupply;
+    uint256 lvBalanceUser;
+    uint256 moduleCoreRaBalance;
+    uint256 userRaBalance;
+    uint256 ammRaBalance;
+    uint256 vaultCtBalance;
+    uint256 psmRaLocked;
+    uint256 lvReserve;
+    uint256 dsTotalSupply;
+    uint256 dsBalanceFlashSwapRouter;
+    uint256 ctTotalSupply;
+    uint256 ctBalanceModuleCore;
+    uint256 ctBalanceHook;
+    uint256 ctBalanceUser;
+    uint256 lpTotalSupply;
+    uint256 lpBalanceModuleCore;
+}
+
+contract LiquidityVaultTest is ModuleCoreTest {
+    ProofState private preState;
+    ProofState private posState;
+
+    function setUp() public override {
+        super.setUp();
+        setSymbolicState(1,0);
+    }
+    
+    function test_depositLV_revert_after_expiry(uint256 amount, uint256 raTolerance, uint256 ctTolerance) public {
+        vm.assume(!moduleCore.getVaultIsDepositPaused(id));
+        vm.assume(amount != 0);
+
+        vm.assume(moduleCore.getDsIsExpired(id));
+        vm.expectRevert(Guard.Expired.selector);
+        moduleCore.depositLv(id, amount, raTolerance, ctTolerance);
+    }
+
+    function _assumeDepositLvPreState(uint256 amount, address depositor, address ra) internal {
+        vm.assume(amount < ETH_UPPER_BOUND);
+        // assume that LVDepositNotPaused(id)
+        vm.assume(!moduleCore.getVaultIsDepositPaused(id));
+        // avoid ICommon.ZeroDeposit()
+        vm.assume(amount != 0);
+        // assume safeBeforeExpired
+        vm.assume(!moduleCore.getDsIsExpired(id));
+
+        TestAsset(moduleCore.getVaultLvAsset(id)._address).setSymbolicBalanceOf(depositor, "lvBalanceOfUser");
+    }
+
+
+    function _mockCallsDepositLV(uint256 amount) internal
+        returns (uint256 splitted, uint256 raAmount, uint256 ctAmount, uint256 receivedLv) {
+        // Mock call to MathHelper.calculatePercentageFee
+        // Proved in MathHelperTest.testCalculatePercentageFee that splitted <= amount
+        splitted = kevm.freshUInt(32, "splitted");
+        vm.assume(splitted > 0);
+        vm.assume(splitted <= amount);
+        vm.mockCall(address(MathHelper), abi.encodeWithSelector(MathHelper.calculatePercentageFee.selector), abi.encode(splitted));
+
+        // Mock call to RouterState.getCurrentPriceRatio
+        // TODO: prove that  0 < ctRatio <= type(uint256).max - 1e18
+        uint256 ctRatio = kevm.freshUInt(32, "ctRatio");
+        vm.assume(ctRatio != 0);
+        vm.mockCall(address(flashSwapRouter), abi.encodeWithSelector(RouterState.getCurrentPriceRatio.selector), abi.encode(uint256(0), ctRatio));
+
+        // Mock call to MathHelper.calculateProvideLiquidityAmountBasedOnCtPrice
+        // Proved in MathHelperTest.testCalculateProvideLiquidityAmountBasedOnCtPrice that ctAmount <= amountLeft
+        // NOTE: If ctAMount == 0 or ctAmount == amountLeft (which implies raAmount == 0) then the invariant does not hold
+        // because moduleCore stays with the ra amountLeft that it does not return to the user, neither converts into
+        // CT and DS neither send to AMM
+        uint256 amountLeft = amount - splitted;
+        ctAmount = kevm.freshUInt(32, "ctAmount");
+        vm.assume(0 < ctAmount);
+        vm.assume(ctAmount < amountLeft);
+
+        raAmount = amountLeft - ctAmount;
+        vm.mockCall(address(MathHelper), abi.encodeWithSelector(MathHelper.calculateProvideLiquidityAmountBasedOnCtPrice.selector), abi.encode(raAmount, ctAmount));
+
+        // Mock call to MathHelper.calculateDepositLv
+        // TODO: prove that calculateDepositLv correctly computes NAV
+        receivedLv = freshUInt256Bounded("receivedLv");
+        vm.mockCall(address(MathHelper), abi.encodeWithSelector(MathHelper.calculateDepositLv.selector), abi.encode(receivedLv));
+    }
+
+    function _stateSnapshot(ProofState storage state, address depositor) internal {
+        TestAsset lvToken = TestAsset(moduleCore.lvAsset(id));
+        state.lvTotalSupply = lvToken.totalSupply();
+        state.lvBalanceUser = lvToken.balanceOf(depositor);
+
+        Pair memory pair = moduleCore.getPairInfo(id);
+        state.moduleCoreRaBalance = IERC20(pair.ra).balanceOf(address(moduleCore));
+        state.userRaBalance = IERC20(pair.ra).balanceOf(depositor);
+        state.ammRaBalance = IERC20(pair.ra).balanceOf(address(hook));
+        
+        state.vaultCtBalance = moduleCore.getVaultBalances(id).ctBalance;
+        state.psmRaLocked = moduleCore.getPsmBalances(id).ra.locked;
+        state.lvReserve = flashSwapRouter.getLvReserve(id, moduleCore.getDsId(id));
+
+        (address ds, address ct) = moduleCore.getDsCtPair(id);
+        state.dsTotalSupply =  TestAsset(ds).totalSupply();
+        state.dsBalanceFlashSwapRouter = TestAsset(ds).balanceOf(address(flashSwapRouter));
+        state.ctTotalSupply = TestAsset(ct).totalSupply();
+        state.ctBalanceModuleCore = TestAsset(ct).balanceOf(address(moduleCore));
+        state.ctBalanceHook = TestAsset(ct).balanceOf(address(hook));
+        state.ctBalanceUser = TestAsset(ct).balanceOf(depositor);
+
+        state.lpTotalSupply = IERC20(lpBase).totalSupply();
+        state.lpBalanceModuleCore = IERC20(lpBase).balanceOf(address(moduleCore));
+    }
+
+    function _assertDepositLVStateChanges(
+        uint256 amount, uint256 splitted, uint256 raAmount, uint256 ctAmount, uint256 receivedLv)
+        internal view {
+        // LVToken expected changes - receivedLV is minted to depositor
+        assertEq(posState.lvTotalSupply, preState.lvTotalSupply + receivedLv);
+        assertEq(posState.lvBalanceUser, preState.lvBalanceUser + receivedLv);
+
+        // Ra balances expected changes
+        uint256 raAdded = hook.raAdded();
+        uint256 raDust = raAmount - raAdded;
+        assertEq(posState.userRaBalance, preState.userRaBalance - amount + raDust);
+        // The following assertion will not hold if ctAmount == 0
+        assertEq(posState.moduleCoreRaBalance, preState.moduleCoreRaBalance + splitted + ctAmount);
+        assertEq(posState.ammRaBalance, preState.ammRaBalance + raAdded);
+
+        // Cork state expected changes
+        assertEq(posState.vaultCtBalance, preState.vaultCtBalance + splitted);
+        assertEq(posState.psmRaLocked, preState.psmRaLocked + splitted + ctAmount);
+        assertEq(posState.lvReserve, preState.lvReserve + splitted + ctAmount);
+
+        // DSToken expected changes
+        assertEq(posState.dsTotalSupply, preState.dsTotalSupply + splitted + ctAmount);
+        assertEq(posState.dsBalanceFlashSwapRouter, preState.dsBalanceFlashSwapRouter + splitted + ctAmount);
+
+        // CTToken expected changes
+        uint256 ctAdded = hook.ctAdded();
+        uint256 ctDust = ctAmount - ctAdded;
+        assertEq(posState.ctTotalSupply, preState.ctTotalSupply + splitted + ctAmount);
+        assertEq(posState.ctBalanceModuleCore, preState.ctBalanceModuleCore + splitted);
+        assertEq(posState.ctBalanceHook, preState.ctBalanceHook + ctAdded);
+        assertEq(posState.ctBalanceUser, preState.ctBalanceUser + ctDust);
+
+        // LP expected changes
+        uint256 lpMinted = hook.lpMinted();
+        assertEq(posState.lpTotalSupply, preState.lpTotalSupply + lpMinted);
+        assertEq(posState.lpBalanceModuleCore, preState.lpBalanceModuleCore + lpMinted);
+    }
+
+
+    function test_depositLV_correctness(uint256 amount, uint256 raTolerance, uint256 ctTolerance) public {
+        address ra = moduleCore.getPairInfo(id).ra;
+        address depositor = raDepositor(ra, amount);
+        bool wasVaultInitialized = moduleCore.getVaultInitialized(id);
+
+        _assumeDepositLvPreState(amount, depositor, ra);
+
+        (uint256 splitted, uint256 raAmount, uint256 ctAmount, uint256 receivedLv) = _mockCallsDepositLV(amount);
+        
+        _stateSnapshot(preState, depositor);
+
+        // Assume invariants hold before the function call
+        _invariant_DS_CT_backed_PA_RA(Mode.Assume);
+        _invariant_ctBalance(Mode.Assume);
+        _invariant_lvReserve(Mode.Assume);
+
+        vm.prank(depositor);
+        moduleCore.depositLv(id, amount, raTolerance, ctTolerance);
+
+        // Assert invariants are preserved by the function call
+        _invariant_DS_CT_backed_PA_RA(Mode.Assert);
+        _invariant_ctBalance(Mode.Assert);
+        _invariant_lvReserve(Mode.Assert);
+
+        _stateSnapshot(posState, depositor);
+
+        if(!wasVaultInitialized) {
+            receivedLv = amount - splitted;
+        }
+
+        if(raAmount == 0 || ctAmount == 0) {
+            raAmount = 0;
+            ctAmount = 0;
+        }
+
+        // Assert that the state changes as expected
+        _assertDepositLVStateChanges(amount, splitted, raAmount, ctAmount, receivedLv);
+    }
+
+    function _assumeRedeemLvPreState(uint256 amount) internal {
+        vm.assume(amount < ETH_UPPER_BOUND);
+        // assume nonReentrant
+        _setReentrancyGuardFalse();
+        // assume that LVWithdrawalNotPaused(id)
+        vm.assume(!moduleCore.getVaultIsWithdrawalPaused(id));
+        // assume safeBeforeExpired
+        vm.assume(!moduleCore.getDsIsExpired(id));
+    }
+
+    function _mockCallsRedeemLV(uint256 amount) internal returns (uint256,uint256) {
+        // Mock call to MathHelper.calculatePercentageFee
+        // Proved in MathHelperTest.testCalculatePercentageFee that fee <= amount
+        uint256 fee = kevm.freshUInt(32, "fee");
+        vm.assume(fee > 0);
+        // 5 ether is the upper bound of self.vault.config.fee
+        vm.assume(fee <= (amount * 5 ether) / (100 * UNIT));
+        vm.mockCall(address(MathHelper), abi.encodeWithSelector(MathHelper.calculatePercentageFee.selector), abi.encode(fee));
+
+        // Mock call to MathHelper.calculateRedeemLv
+        // TODO: prove that calculateRedeemLv correctly computes ctReceived, dsReceived and lpLiquidated
+        (uint256 ctReceived, uint256 dsReceived, uint256 lpLiquidated, uint256 paReceived, uint256 idleRaReceived) = 
+            (freshUInt256Bounded("ctReceived"),
+             freshUInt256Bounded("dsReceived"), 
+             freshUInt256Bounded("lpLiquidated"),
+             freshUInt256Bounded("paReceived"),
+             freshUInt256Bounded("idleRaReceived"));
+        MathHelper.RedeemResult memory result = 
+            MathHelper.RedeemResult(ctReceived, dsReceived, lpLiquidated, paReceived, idleRaReceived);
+        vm.assume(ctReceived <= moduleCore.getVaultBalances(id).ctBalance);
+        (address ds, address ct) = moduleCore.getDsCtPair(id);
+        vm.assume(ctReceived <= moduleCore.getVaultBalances(id).ctBalance);
+        vm.assume(dsReceived <= flashSwapRouter.getLvReserve(id, moduleCore.getDsId(id)));
+        vm.assume(lpLiquidated <= IERC20(lpBase).balanceOf(address(moduleCore)));
+        vm.assume(paReceived <= IERC20(moduleCore.getPairInfo(id).pa).balanceOf(address(moduleCore)));
+        vm.assume(idleRaReceived <= IERC20(moduleCore.getPairInfo(id).ra).balanceOf(address(moduleCore)));
+        vm.mockCall(address(MathHelper), abi.encodeWithSelector(MathHelper.calculateRedeemLv.selector), abi.encode(result));
+
+        address withdrawalContract = moduleCore.withdrawalContract();
+        vm.mockCall(withdrawalContract, abi.encodeWithSelector(Withdrawal.add.selector), abi.encode(bytes32(0)));
+
+        return (fee, lpLiquidated);
+    }
+
+    function _assertRedeemLVStateChanges(uint256 amount, uint256 lpLiquidated, IVault.RedeemEarlyResult memory result)
+        internal view {
+        // LVToken expected changes - receivedLV is minted to depositor
+        assertEq(posState.lvTotalSupply, preState.lvTotalSupply - amount);
+        assertEq(posState.lvBalanceUser, preState.lvBalanceUser - amount);
+
+        // Ra balances expected changes
+        assertEq(posState.userRaBalance, preState.userRaBalance + result.raReceivedFromAmm);
+        assertEq(posState.moduleCoreRaBalance, preState.moduleCoreRaBalance);
+        assertEq(posState.ammRaBalance, preState.ammRaBalance - result.raReceivedFromAmm);
+
+        // Cork state expected changes
+        assertEq(posState.vaultCtBalance, preState.vaultCtBalance - result.ctReceivedFromVault);
+        assertEq(posState.psmRaLocked, preState.psmRaLocked);
+        assertEq(posState.lvReserve, preState.lvReserve - result.dsReceived);
+
+        // DSToken expected changes
+        assertEq(posState.dsTotalSupply, preState.dsTotalSupply);
+        assertEq(posState.dsBalanceFlashSwapRouter, preState.dsBalanceFlashSwapRouter - result.dsReceived);
+
+        // CTToken expected changes
+        assertEq(posState.ctTotalSupply, preState.ctTotalSupply);
+        assertEq(posState.ctBalanceModuleCore, preState.ctBalanceModuleCore - result.ctReceivedFromVault);
+        assertEq(posState.ctBalanceHook, preState.ctBalanceHook - result.ctReceivedFromAmm);
+        assertEq(posState.ctBalanceUser, preState.ctBalanceUser + result.ctReceivedFromVault + result.ctReceivedFromAmm);
+
+        // LP expected changes
+        assertEq(posState.lpTotalSupply, preState.lpTotalSupply - lpLiquidated);
+        assertEq(posState.lpBalanceModuleCore, preState.lpBalanceModuleCore - lpLiquidated);
+    }
+
+    function test_redeemLV_correctness(uint256 amount, uint256 amountOutMin, uint256 ammDeadline) public {
+        IVault.RedeemEarlyParams memory redeemParams = IVault.RedeemEarlyParams(id, amount, amountOutMin, ammDeadline);
+        hook.setAmountOutMin(amountOutMin);
+
+        _assumeRedeemLvPreState(amount);
+        
+        (uint256 fee, uint256 lpLiquidated) = _mockCallsRedeemLV(amount);
+
+        address redeemer = lvRedeemer(amount + fee);
+
+        _stateSnapshot(preState, redeemer);
+
+        // Assume invariants hold before the function call
+        _invariant_DS_CT_backed_PA_RA(Mode.Assume);
+        _invariant_ctBalance(Mode.Assume);
+        _invariant_lvReserve(Mode.Assume);
+
+        vm.prank(redeemer);
+        IVault.RedeemEarlyResult memory result = moduleCore.redeemEarlyLv(redeemParams);
+
+        // Assert invariants are preserved by the function call
+        _invariant_DS_CT_backed_PA_RA(Mode.Assert);
+        _invariant_ctBalance(Mode.Assert);
+        _invariant_lvReserve(Mode.Assert);
+
+        _stateSnapshot(posState, redeemer);
+
+        // Assert that the state changes as expected
+        _assertRedeemLVStateChanges(amount, lpLiquidated, result);
+    }
+}
\ No newline at end of file
diff --git a/test/forge/kontrol/MathHelperTest.k.sol b/test/forge/kontrol/MathHelperTest.k.sol
new file mode 100644
index 0000000..c3e39e2
--- /dev/null
+++ b/test/forge/kontrol/MathHelperTest.k.sol
@@ -0,0 +1,72 @@
+pragma solidity ^0.8.24;
+
+import {MathHelper} from "../../../contracts/libraries/MathHelper.sol";
+
+import {KontrolTest} from "./KontrolTest.k.sol";
+
+
+contract MathHelperTest is KontrolTest {
+
+    uint256 constant UNIT = 1e18;
+    uint256 constant ETH_UPPER_BOUND = 2 ** 95;
+
+    function testCalculatePercentageFee(uint256 amount, uint256 ctHeldPercentage) public pure {
+        vm.assume(amount > 0);
+        vm.assume(ctHeldPercentage >= 0.001 ether);
+        vm.assume(ctHeldPercentage <= 100 ether);
+        vm.assume(amount < type(uint256).max / ctHeldPercentage);
+
+        uint256 splitted = MathHelper.calculatePercentageFee(ctHeldPercentage, amount);
+
+        vm.assertLe(splitted, amount);
+        vm.assertEq(splitted, (amount * ctHeldPercentage) / (100 * UNIT));
+    }
+
+    function testCalculateProvideLiquidityAmountBasedOnCtPrice(uint256 amountRa, uint256 priceRatio) public pure {
+        vm.assume(priceRatio != 0);
+        vm.assume(amountRa < type(uint256).max / UNIT);
+        vm.assume(priceRatio < type(uint256).max - UNIT);
+        (uint256 ra, uint256 ct) = MathHelper.calculateProvideLiquidityAmountBasedOnCtPrice(amountRa, priceRatio);
+
+        vm.assertLe(ra, amountRa);
+        vm.assertLe(ct, amountRa);
+
+        uint256 ctExpected = (amountRa * UNIT) / (priceRatio + UNIT);
+        vm.assertEq(ct, ctExpected);
+        vm.assertEq(ra, amountRa - ctExpected);
+    }
+
+    function testCalculateRedeemLv(MathHelper.RedeemParams calldata params) public pure {
+        vm.assume(0 < params.amountLvClaimed);
+        // We know this is true when we call the function in redeemLv otherwise the function reverts in burnFrom
+        vm.assume(params.amountLvClaimed <= params.totalLvIssued);
+        // Overflow check assumptions
+        vm.assume(params.amountLvClaimed < type(uint256).max / UNIT);
+        vm.assume(params.totalLvIssued < ETH_UPPER_BOUND);
+        vm.assume(params.totalVaultLp < ETH_UPPER_BOUND);
+        vm.assume(params.totalVaultCt < ETH_UPPER_BOUND);
+        vm.assume(params.totalVaultDs < ETH_UPPER_BOUND);
+        vm.assume(params.totalVaultPA < ETH_UPPER_BOUND);
+        vm.assume(params.totalVaultIdleRa < ETH_UPPER_BOUND);
+
+        MathHelper.RedeemResult memory result = MathHelper.calculateRedeemLv(params);
+
+        vm.assertLe(result.lpLiquidated, params.totalVaultLp);
+        vm.assertLe(result.ctReceived, params.totalVaultCt);
+        vm.assertLe(result.dsReceived, params.totalVaultDs);
+
+        uint256 proportionalClaim = (params.amountLvClaimed * UNIT) / params.totalLvIssued;
+        vm.assertEq(result.ctReceived, (proportionalClaim * params.totalVaultCt) / UNIT);
+        vm.assertEq(result.dsReceived, (proportionalClaim * params.totalVaultDs) / UNIT);
+        vm.assertEq(result.lpLiquidated, (proportionalClaim * params.totalVaultLp) / UNIT);
+    }
+
+    function testCalculateEqualSwapAmount(uint256 amount, uint256 exchangeRates) public pure {
+        vm.assume(exchangeRates > 0);
+        vm.assume(amount < type(uint256).max / exchangeRates);
+
+        uint256 raDs = MathHelper.calculateEqualSwapAmount(amount, exchangeRates);
+
+        vm.assertEq(raDs, amount * exchangeRates / UNIT);
+    }
+}
\ No newline at end of file
diff --git a/test/forge/kontrol/ModuleCoreTest.k.sol b/test/forge/kontrol/ModuleCoreTest.k.sol
new file mode 100644
index 0000000..67a4b0b
--- /dev/null
+++ b/test/forge/kontrol/ModuleCoreTest.k.sol
@@ -0,0 +1,224 @@
+pragma solidity ^0.8.24;
+
+import {TestModuleCore} from "./TestModuleCore.k.sol";
+import {TestAssetFactory} from "./TestAssetFactory.k.sol";
+import {TestFlashSwapRouter} from "./TestFlashSwapRouter.k.sol";
+import {TestCorkConfig} from "./TestCorkConfig.k.sol";
+import {TestCorkHook} from "./TestCorkHook.k.sol";
+import {TestAsset} from "./TestAsset.k.sol";
+import {TestERC20} from "./TestERC20.t.sol";
+
+import {Id, Pair, PairLibrary} from "../../../contracts/libraries/Pair.sol";
+import {ICommon} from "../../../contracts/interfaces/ICommon.sol";
+import {PeggedAsset, PeggedAssetLibrary} from "../../../contracts/libraries/PeggedAssetLib.sol";
+import {DepegSwap} from "../../../contracts/libraries/DepegSwapLib.sol";
+
+import {PoolManager} from "v4-core/PoolManager.sol";
+import {ProtocolFeeControllerTest} from "v4-periphery/lib/v4-core/src/test/ProtocolFeeControllerTest.sol";
+import {Hooks} from "v4-core/libraries/Hooks.sol";
+import {LiquidityToken} from "Cork-Hook/CorkHook.sol";
+
+import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
+
+import {KontrolTest} from "./KontrolTest.k.sol";
+
+contract ModuleCoreTest is KontrolTest {
+    using PairLibrary for Pair;
+
+    uint256 constant UNIT = 1e18;
+
+    TestModuleCore      internal moduleCore;
+    TestCorkConfig      internal corkConfig;
+    TestFlashSwapRouter internal flashSwapRouter;
+    TestAssetFactory    internal assetFactory;
+    TestCorkHook        internal hook;
+
+    // Supplementary contracts for CorkHook
+    PoolManager internal manager;
+    ProtocolFeeControllerTest internal feeController;
+    TestAsset internal token0;
+    TestAsset internal token1;
+    TestERC20 internal lpBase;
+
+    Id id;
+
+    function setUp() public virtual {
+        // Setting up a UniV4 hook contract
+        manager = new PoolManager();
+        // WARNING: For the purpose of the current proofs is enough lpBase to be ERC20. Change it to LIquidityToken is necessary.
+        lpBase = new TestERC20("LP");
+        hook = new TestCorkHook(address(manager), address(lpBase));
+
+        corkConfig = new TestCorkConfig();
+        moduleCore = new TestModuleCore();
+        flashSwapRouter = new TestFlashSwapRouter(address(corkConfig), address(moduleCore));
+        assetFactory = new TestAssetFactory();
+
+        corkConfig.setModuleCore(address(moduleCore));
+        
+        flashSwapRouter.initialize(address(corkConfig));
+        flashSwapRouter.setModuleCore(address(moduleCore));
+        flashSwapRouter.setHook(address(hook));
+
+        assetFactory.initialize();
+        assetFactory.transferOwnership(address(moduleCore));
+
+        moduleCore.initialize(
+            address(assetFactory),
+            address(hook),
+            address(flashSwapRouter),
+            address(corkConfig)
+        );
+    }
+
+
+    function setSymbolicState(uint256 dsId, uint256 hyia) internal {
+        address pa = address(new TestERC20("PA"));
+        address ra = address(new TestERC20("RA"));
+
+        // TODO: try to make expiryInterval symbolic later
+        Pair memory key = PairLibrary.initalize(pa, ra, 0);
+        id = key.toId();
+
+        uint256 expiry = kevm.freshUInt(32, "expiry");
+        vm.assume(expiry != 0);
+        uint256 psmExchangeRate = freshUInt256Bounded("psmExchangeRate");
+        vm.assume(psmExchangeRate != 0);
+
+        address ds = address(new TestAsset("DS","RA-PA", address(moduleCore), expiry, psmExchangeRate, dsId));
+        address ct = address(new TestAsset("CT","RA-PA", address(moduleCore), expiry, psmExchangeRate, dsId));
+        address lv = address(new TestAsset("LV","RA-PA", address(moduleCore), 0, 0, 0));
+
+        TestERC20(ra).setSymbolicBalanceOf(address(moduleCore), "raBalanceOfModuleCore");
+        TestERC20(pa).setSymbolicBalanceOf(address(moduleCore), "paBalanceOfModuleCore");
+        TestAsset(ds).setSymbolicBalanceOf(address(moduleCore), "dsBalanceOfModuleCore");
+        TestAsset(ct).setSymbolicBalanceOf(address(moduleCore), "ctBalanceOfModuleCore");
+
+        TestERC20(ra).setSymbolicBalanceOf(address(hook), "raBalanceOfHook");
+        TestERC20(ct).setSymbolicBalanceOf(address(hook), "ctBalanceOfHook");
+        TestAsset(ds).setSymbolicBalanceOf(address(flashSwapRouter), "dsBalanceOfRouter");
+
+        TestERC20(lpBase).setSymbolicBalanceOf(address(moduleCore), "lpBalanceOfModuleCore");
+        TestERC20(lpBase).setSymbolicAllowance(address(moduleCore), address(hook), "lpAllowanceCoreHook");
+
+        TestAsset(ds).setSymbolicAllowance(address(moduleCore), address(flashSwapRouter), "dsAllowanceCoreRouter");
+        TestAsset(ct).setSymbolicAllowance(address(moduleCore), address(hook), "ctAllowanceCoreHook");
+        TestERC20(ra).setSymbolicAllowance(address(moduleCore), address(hook), "raAllowanceCoreHook");
+
+        moduleCore.setSymbolicState(id, dsId, key, ds, ct, lv);
+        flashSwapRouter.setSymbolicState(id, dsId, ra, ds, ct, hyia);
+    }
+
+    function _setReentrancyGuardFalse() internal {
+        bytes32 REENTRANCY_GUARD_STORAGE = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;
+
+        vm.store(address(moduleCore), REENTRANCY_GUARD_STORAGE, bytes32(0));
+    }
+
+
+    function raDepositor(address ra, uint256 amount) internal returns (address depositor) {
+        depositor = address(0xABCDE);
+        TestERC20(ra).setSymbolicBalanceOf(depositor, "raBalanceOfUser");
+        TestERC20(ra).setSymbolicAllowance(depositor, address(moduleCore), "raAllowanceUserCore");
+
+        uint256 depositorRaBalance = IERC20(ra).balanceOf(depositor);
+        vm.assume(depositorRaBalance >= amount);
+
+        uint256 allowance = IERC20(ra).allowance(depositor, address(moduleCore));
+        vm.assume(allowance >= amount);
+
+        (address ds, address ct) = moduleCore.getDsCtPair(id);
+        TestAsset(ds).setSymbolicBalanceOf(address(depositor), "dsBalanceOfUser");
+        TestAsset(ct).setSymbolicBalanceOf(address(depositor), "ctBalanceOfUser");
+    }
+
+    function psmRedeemerWithDs(uint256 amount, uint256 dsProvided) internal returns (address redeemer) {
+        redeemer = address(0xABCDE);
+
+        Pair memory info = moduleCore.getPairInfo(id);
+
+        TestERC20(info.pa).setSymbolicBalanceOf(redeemer, "paBalanceOfUser");
+        TestERC20(info.pa).setSymbolicAllowance(redeemer, address(moduleCore), "paAllowanceUserCore");
+        uint256 redeemerPaBalance = IERC20(info.pa).balanceOf(redeemer);
+        vm.assume(redeemerPaBalance >= amount);
+        uint256 allowancePa = IERC20(info.pa).allowance(redeemer, address(moduleCore));
+        vm.assume(allowancePa >= amount);
+
+        TestERC20(info.ra).setSymbolicBalanceOf(redeemer, "raBalanceOfUser");
+        vm.assume(dsProvided <= IERC20(info.ra).balanceOf(address(moduleCore)));
+
+        (address ds, address ct) = moduleCore.getDsCtPair(id);
+        TestAsset(ds).setSymbolicBalanceOf(redeemer, "dsBalanceOfUser");
+        uint256 redeemerDsBalance = IERC20(ds).balanceOf(redeemer);
+        vm.assume(redeemerDsBalance >= dsProvided);
+
+        TestAsset(ds).setSymbolicAllowance(redeemer, address(moduleCore), "dsAllowanceUserCore");
+        uint256 allowanceDs = IERC20(ds).allowance(redeemer, address(moduleCore));
+        vm.assume(allowanceDs >= dsProvided);
+
+        TestAsset(ct).setSymbolicBalanceOf(redeemer, "ctBalanceOfUser");
+    }
+
+    function lvRedeemer(uint256 amount) internal returns (address redeemer) {
+        redeemer = address(0xABCDE);
+        TestAsset lvToken = TestAsset(moduleCore.lvAsset(id));
+        lvToken.setSymbolicBalanceOf(redeemer, "lvBalanceOfUser");
+        lvToken.setSymbolicAllowance(redeemer, address(moduleCore), "lvAllowanceUserCore");
+
+        uint256 redeemerLvBalance = lvToken.balanceOf(redeemer);
+        vm.assume(redeemerLvBalance >= amount);
+
+        uint256 allowance = lvToken.allowance(redeemer, address(moduleCore));
+        vm.assume(allowance >= amount);
+
+        Pair memory info = moduleCore.getPairInfo(id);
+        TestERC20(info.ra).setSymbolicBalanceOf(redeemer, "raBalanceOfUser");
+
+        (address ds, address ct) = moduleCore.getDsCtPair(id);
+        TestAsset(ds).setSymbolicBalanceOf(redeemer, "dsBalanceOfUser");
+        TestAsset(ct).setSymbolicBalanceOf(redeemer, "ctBalanceOfUser");
+
+        address withdrawalContract = moduleCore.withdrawalContract();
+        TestERC20(info.ra).setSymbolicBalanceOf(withdrawalContract, "raBalanceOfWithdrawal");
+        TestERC20(info.pa).setSymbolicBalanceOf(withdrawalContract, "paBalanceOfWithdrawal");
+        TestAsset(ds).setSymbolicBalanceOf(withdrawalContract, "dsBalanceOfWithdrawal");
+        TestAsset(ct).setSymbolicBalanceOf(withdrawalContract, "ctBalanceOfWithdrawal");
+    }
+    
+
+    function _get_DS_CT_PA_RA(Id pairId) internal view returns (address ds, address ct, address ra, address pa) {
+        (ds, ct) = moduleCore.getDsCtPair(pairId);
+        
+        Pair memory info = moduleCore.getPairInfo(pairId);
+        ra = info.ra;
+        pa = info.pa;
+    }
+
+
+    function _invariant_DS_CT_backed_PA_RA(Mode mode) internal view {
+        (address dsToken, address ctToken, address ra, address pa) = _get_DS_CT_PA_RA(id);
+
+        // Confirm if it's the totalSupply or the balances of these tokens
+        uint256 dsTotalSupply = IERC20(dsToken).totalSupply();
+        uint256 ctTotalSupply = IERC20(ctToken).totalSupply();
+
+        _establish(mode, dsTotalSupply == ctTotalSupply);
+
+        uint256 paBalance = IERC20(pa).balanceOf(address(moduleCore));
+        uint256 raBalance = IERC20(ra).balanceOf(address(moduleCore));
+
+        _establish(mode, dsTotalSupply == (paBalance + raBalance));
+    }
+
+
+    function _invariant_ctBalance(Mode mode) internal view {
+        (, address ct) = moduleCore.getDsCtPair(id);
+        _establish(mode, moduleCore.getVaultBalances(id).ctBalance == IERC20(ct).balanceOf(address(moduleCore)));
+    }
+
+    function _invariant_lvReserve(Mode mode) internal view {
+        (address ds,) = moduleCore.getDsCtPair(id);
+        uint256 dsId = moduleCore.getDsId(id);
+        _establish(mode, flashSwapRouter.getLvReserve(id, dsId) == IERC20(ds).balanceOf(address(flashSwapRouter)));
+    }
+}
\ No newline at end of file
diff --git a/test/forge/kontrol/PsmTest.k.sol b/test/forge/kontrol/PsmTest.k.sol
new file mode 100644
index 0000000..367edae
--- /dev/null
+++ b/test/forge/kontrol/PsmTest.k.sol
@@ -0,0 +1,187 @@
+pragma solidity ^0.8.24;
+
+import {ModuleCoreTest} from "./ModuleCoreTest.k.sol";
+import {TestAsset}     from "./TestAsset.k.sol";
+import {TestERC20} from "./TestERC20.t.sol";
+
+import {Id, Pair} from "../../../contracts/libraries/Pair.sol";
+import {ICommon} from "../../../contracts/interfaces/ICommon.sol";
+import {MathHelper} from "../../../contracts/libraries/MathHelper.sol";
+import {RouterState} from "../../../contracts/core/flash-swaps/FlashSwapRouter.sol";
+
+import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
+
+import "./Constants.k.sol";
+
+struct ProofState {
+    uint256 moduleCoreRaBalance;
+    uint256 depositorRaBalance;
+    uint256 psmRaLocked; 
+    uint256 dsTotalSupply;
+    uint256 ctTotalSupply;
+    uint256 dsBalanceDepositor;
+    uint256 ctBalanceDepositor;
+}
+
+contract PsmTest is ModuleCoreTest {
+    ProofState private preState;
+    ProofState private posState;
+
+    function setUp() public override {
+        super.setUp();
+        setSymbolicState(1,0);
+    }
+
+    function test_reinitialize_fail(
+        address _pa,
+        address _ra,
+        uint256 lvFee,
+        uint256 initialDsPrice,
+        uint256 psmBaseRedemptionFeePercentage,
+        uint256 _expiryInterval)
+    public {
+        Pair memory key = Pair({pa: _pa, ra: _ra, expiryInterval: _expiryInterval});
+        id = Id.wrap(keccak256(abi.encode(key)));
+
+        vm.assume(moduleCore.getIsInitialized(id));
+        vm.startPrank(address(corkConfig));
+        vm.expectRevert(ICommon.AlreadyInitialized.selector);
+        moduleCore.initializeModuleCore(_pa, _ra, lvFee, initialDsPrice, psmBaseRedemptionFeePercentage, _expiryInterval);
+    }
+
+    function _stateSnapshotDepositPSM(ProofState storage state, address depositor) internal {
+        Pair memory pair = moduleCore.getPairInfo(id);
+        state.moduleCoreRaBalance = IERC20(pair.ra).balanceOf(address(moduleCore));
+        state.depositorRaBalance = IERC20(pair.ra).balanceOf(depositor);
+        
+        state.psmRaLocked = moduleCore.getPsmBalances(id).ra.locked;
+
+        (address ds, address ct) = moduleCore.getDsCtPair(id);
+        state.dsTotalSupply =  IERC20(ds).totalSupply();
+        state.ctTotalSupply = IERC20(ct).totalSupply();
+        state.dsBalanceDepositor = IERC20(ds).balanceOf(depositor);
+        state.ctBalanceDepositor = IERC20(ct).balanceOf(depositor);
+    }
+
+
+    function _assertDepositLVStateChanges(uint256 amount) internal view {
+        assertEq(posState.moduleCoreRaBalance, preState.moduleCoreRaBalance + amount);
+        assertEq(posState.depositorRaBalance, preState.depositorRaBalance - amount);
+        assertEq(posState.dsBalanceDepositor, preState.dsBalanceDepositor + amount);
+        assertEq(posState.ctBalanceDepositor, preState.ctBalanceDepositor + amount);
+        assertEq(posState.dsTotalSupply, preState.dsTotalSupply + amount);
+        assertEq(posState.ctTotalSupply, preState.ctTotalSupply + amount);
+        assertEq(posState.psmRaLocked, preState.psmRaLocked + amount);
+    }
+
+
+    function test_deposit_PSM_correctness(uint256 amount) public {
+        vm.assume(amount != 0);
+        vm.assume(amount < ETH_UPPER_BOUND);
+        vm.assume(!moduleCore.getPsmIsDepositPaused(id));
+        // assume safeBeforeExpired
+        vm.assume(!moduleCore.getDsIsExpired(id));
+
+        address ra = moduleCore.getPairInfo(id).ra;
+        address depositor = raDepositor(ra, amount);
+
+        _stateSnapshotDepositPSM(preState, depositor);
+
+        // Assume invariants hold before the function call
+        _invariant_DS_CT_backed_PA_RA(Mode.Assume);
+        _invariant_ctBalance(Mode.Assume);
+        _invariant_lvReserve(Mode.Assume);
+
+        // Make the deposit
+        vm.prank(depositor);
+        (uint256 received, uint256 _exchangeRate) = moduleCore.depositPsm(id, amount);
+
+        // Assert invariants are preserved by the function call
+        _invariant_DS_CT_backed_PA_RA(Mode.Assert);
+        _invariant_ctBalance(Mode.Assert);
+        _invariant_lvReserve(Mode.Assert);
+
+        _stateSnapshotDepositPSM(posState, depositor);
+
+        // Assert that the state changes as expected
+        _assertDepositLVStateChanges(amount);
+    }
+
+    function _mockCallsRedeemRaWithDs(uint256 amount) internal returns (uint256 raReceived, uint256 dsProvided) {
+        // Proved in MathHelperTest.testCalculatePercentageFee that ra == amount * exchangeRates / UNIT
+        uint256 ra = freshUInt256Bounded("ra");
+        vm.mockCall(address(MathHelper), abi.encodeWithSelector(MathHelper.calculateEqualSwapAmount.selector), abi.encode(ra));
+        // underflow check assumption
+        vm.assume(ra <= moduleCore.getPsmBalances(id).ra.locked);
+        
+        dsProvided = ra;
+
+        // Mock call to MathHelper.calculatePercentageFee
+        // Proved in MathHelperTest.testCalculatePercentageFee that fee <= amount
+        uint256 fee = kevm.freshUInt(32, "fee");
+        // 5 ether is the upper bound of psmBaseRedemptionFeePercentage
+        vm.assume(fee <= (ra * 5 ether) / (100 * UNIT));
+        //vm.assume(fee <= ra);
+        vm.mockCall(address(MathHelper), abi.encodeWithSelector(MathHelper.calculatePercentageFee.selector), abi.encode(fee));
+
+        raReceived = ra - fee;
+
+        // We can mock this function with 0 because we are not using the returned values since hook.addLiquidity
+        // also has a mocked implementation
+        vm.mockCall(address(MathHelper), abi.encodeWithSelector(MathHelper.calculateWithTolerance.selector), abi.encode(uint256(0),uint256(0)));
+    
+        // Mock call to RouterState.getCurrentPriceRatio
+        // TODO: prove that  0 < ctRatio <= type(uint256).max - 1e18
+        uint256 ctRatio = kevm.freshUInt(32, "ctRatio");
+        vm.assume(ctRatio != 0);
+        vm.mockCall(address(flashSwapRouter), abi.encodeWithSelector(RouterState.getCurrentPriceRatio.selector), abi.encode(uint256(0), ctRatio));
+
+        // Mock call to MathHelper.calculateProvideLiquidityAmountBasedOnCtPrice
+        // Proved in MathHelperTest.testCalculateProvideLiquidityAmountBasedOnCtPrice that ctAmount <= amountLeft
+        // NOTE: If ctAMount == 0 or ctAmount == amountLeft (which implies raAmount == 0) then the invariant does not hold
+        // because moduleCore stays with the ra amountLeft that it does not return to the user, neither converts into
+        // CT and DS neither send to AMM
+        uint256 ctAmount = kevm.freshUInt(32, "ctAmount");
+        vm.assume(0 < ctAmount);
+        vm.assume(ctAmount < fee);
+
+        uint256 raAmount = fee - ctAmount;
+        vm.mockCall(address(MathHelper), abi.encodeWithSelector(MathHelper.calculateProvideLiquidityAmountBasedOnCtPrice.selector), abi.encode(raAmount, ctAmount));
+    }
+
+
+    function test_redeemRaWithDs_correctness(uint256 amount) public {
+        vm.assume(amount < ETH_UPPER_BOUND);
+        // assume nonReentrant
+        _setReentrancyGuardFalse();
+        // Assume PSM withdrawal is not paused
+        vm.assume(!moduleCore.getPsmIsWithdrawalPaused(id));
+        // assume safeBeforeExpired
+        vm.assume(!moduleCore.getDsIsExpired(id));
+
+        (uint256 raReceived, uint256 dsProvided) = _mockCallsRedeemRaWithDs(amount);
+
+        address redeemer = psmRedeemerWithDs(amount, dsProvided);
+
+        //_stateSnapshotRedeemPSM(preState, redeemer);
+
+        // Assume invariants hold before the function call
+        _invariant_DS_CT_backed_PA_RA(Mode.Assume);
+        _invariant_ctBalance(Mode.Assume);
+        _invariant_lvReserve(Mode.Assume);
+
+        // Redeem
+        uint256 dsId = moduleCore.getDsId(id);
+        vm.prank(redeemer);
+        (uint256 received, uint256 _exchangeRate, uint256 fee, uint256 dsUsed) = moduleCore.redeemRaWithDs(id, dsId, amount);
+
+        // Assume invariants hold before the function call
+        _invariant_DS_CT_backed_PA_RA(Mode.Assume);
+        _invariant_ctBalance(Mode.Assume);
+        _invariant_lvReserve(Mode.Assume);
+
+        //_stateSnapshotRedeemPSM(posState, redeemer);
+
+        // Assert that the state changes as expected
+    }
+}
\ No newline at end of file
diff --git a/test/forge/kontrol/RouterTest.k.sol b/test/forge/kontrol/RouterTest.k.sol
new file mode 100644
index 0000000..c7e3946
--- /dev/null
+++ b/test/forge/kontrol/RouterTest.k.sol
@@ -0,0 +1,270 @@
+pragma solidity ^0.8.24;
+
+import {ModuleCoreTest} from "./ModuleCoreTest.k.sol";
+
+import {Id, Pair}        from "../../../contracts/libraries/Pair.sol";
+import {IDsFlashSwapCore} from "../../../contracts/interfaces/IDsFlashSwapRouter.sol";
+import {SwapperMathLibrary} from "../../../contracts/libraries/DsSwapperMathLib.sol";
+import {AssetPair} from "../../../contracts/libraries/DsFlashSwap.sol";
+
+import {Asset}     from "../../../contracts/core/assets/Asset.sol";
+import {TestAsset}     from "./TestAsset.k.sol";
+import {TestERC20} from "./TestERC20.t.sol";
+
+import {KontrolTest} from "./KontrolTest.k.sol";
+
+import {IERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
+
+/* An alternative approach to use `vm.mockCall` is to deploy a mock contract and call the function on it
+ using the `vm.mockFunction` cheatcode */
+contract ModuleCoreMock {
+    function lvAcceptRolloverProfit(Id id, uint256 amount) external {}    
+}
+
+contract RouterTest is ModuleCoreTest {
+    ProofState private preState;
+    ProofState private posState;
+
+    struct ProofState {
+        uint256 moduleCoreRaBalance;
+        uint256 sellerRaBalance;
+        uint256 sellerDsBalance;
+        uint256 routerRaBalance;
+        uint256 routerDsBalance;
+        uint256 moduleCorePsmPoolArchiveRolloverProfit;
+        uint256 moduleCorePsmReserve;
+        uint256 moduleCoreLvReserve;
+    }
+
+    function setUp() public override {
+        super.setUp();
+
+        uint256 hyia = freshUInt256Bounded("hiya");
+        setSymbolicState(2, hyia);
+    }
+
+    function _assumeSwapRaForDsPreState(address seller, uint256 amount) internal {
+        Pair memory pair = moduleCore.getPairInfo(id);
+        (address ds, address ct) = moduleCore.getDsCtPair(id);
+        uint256 dsId = moduleCore.getDsId(id);
+
+        address ra = pair.ra;
+
+        // Assume `amount` is positive
+        vm.assume(amount > 0);
+
+        // Seller has symbolic amount of DS and RA
+        TestERC20(ra).setSymbolicBalanceOf(seller, "sellerRaBalance");        
+        TestERC20(ra).setSymbolicAllowance(seller, address(flashSwapRouter), "sellerRouterRaAllowance");
+        TestAsset(ds).setSymbolicBalanceOf(seller, "sellerDsBalance");
+
+        uint256 sellerBalanceRa = TestERC20(ra).balanceOf(seller);
+
+        // Seller has a sufficient balance of RA to transfer `amount`
+        vm.assume(sellerBalanceRa >= amount);
+        // Seller has given a sufficient allowance of RA to the router
+        uint256 allowance = TestERC20(ra).allowance(seller, address(flashSwapRouter));
+        vm.assume(allowance >= amount);
+
+        // FlashSwapRouter has symbolic amount of DS and RA
+        TestAsset(ds).setSymbolicBalanceOf(address(flashSwapRouter), "routerDsBalance");
+        TestERC20(ra).setSymbolicBalanceOf(address(flashSwapRouter), "routerRaBalance");
+
+        uint256 routerBalanceRa = TestERC20(ra).balanceOf(address(flashSwapRouter));
+
+        // Assuming that no overflow occurs on transfer to the router
+        vm.assume(routerBalanceRa <= type(uint256).max - amount);
+
+        // Assuming that hiya is not 0 to enable rollover sale, prevent branching on its values,
+        // and that it is sufficiently small to not overflow
+        vm.assume(flashSwapRouter.getHiya(id) > 0);
+        vm.assume(flashSwapRouter.getHiyeCumulated(id) > 0);
+        vm.assume(flashSwapRouter.getHiyeCumulated(id) <= 1e8);
+        vm.assume(flashSwapRouter.getVhiyaCumulated(id) <= 1e8);
+    }
+
+    function _stateSnapshotSwap(ProofState storage state, address seller) internal {
+        Pair memory pair = moduleCore.getPairInfo(id);
+        (address ds, address ct) = moduleCore.getDsCtPair(id);
+        uint256 dsId = moduleCore.getDsId(id);
+
+        state.moduleCoreRaBalance = IERC20(pair.ra).balanceOf(address(moduleCore));
+        state.routerRaBalance = IERC20(pair.ra).balanceOf(address(flashSwapRouter));
+        state.routerDsBalance = TestAsset(ds).balanceOf(address(flashSwapRouter));
+        state.sellerRaBalance = IERC20(pair.ra).balanceOf(seller);
+        state.sellerDsBalance = TestAsset(ds).balanceOf(seller);
+        state.moduleCorePsmPoolArchiveRolloverProfit = moduleCore.getPsmPoolArchiveRolloverProfit(id, dsId);
+        state.moduleCorePsmReserve = flashSwapRouter.getAssetPair(id, dsId).psmReserve;
+        state.moduleCoreLvReserve = flashSwapRouter.getAssetPair(id, dsId).lvReserve;
+    }
+
+    function _mockSwapRaForDsRouterCalls(uint256 amount, uint256 amountOutMin) internal returns (uint256 psmProfit, uint256 lvProfit, uint256 psmReserveUsed, uint256 lvReserveUsed) {
+        // Mocking the `lvAcceptRolloverProfit` function; depositing into LV is covered by a separate proof
+        ModuleCoreMock mock = new ModuleCoreMock();
+        vm.mockFunction(
+            address(moduleCore), address(mock), abi.encodeWithSelector(ModuleCoreMock.lvAcceptRolloverProfit.selector)
+        );
+
+        // Mocking the result of hiya calculation with an arbitrary concrete value, assuming it doesn't overflow
+        vm.mockCall(address(SwapperMathLibrary), abi.encodeWithSelector(SwapperMathLibrary.calcHIYAaccumulated.selector), abi.encode(1));
+        vm.mockCall(address(SwapperMathLibrary), abi.encodeWithSelector(SwapperMathLibrary.calcVHIYAaccumulated.selector), abi.encode(1));
+ 
+        uint256 dsReceived;
+        uint256 raLeft;
+         // Mocking the call to `calculateRolloverSale`
+        (lvProfit, psmProfit, raLeft, dsReceived, lvReserveUsed, psmReserveUsed) = (
+            freshUInt256Bounded("lvProfit"),
+            freshUInt256Bounded("psmProfit"),
+            freshUInt256Bounded("raLeft"),
+            freshUInt256Bounded("dsReceived"),
+            freshUInt256Bounded("lvReserveUsed"),
+            freshUInt256Bounded("psmReserveUsed")
+        );
+
+        // Returning after rollover sale as the swap has been completed
+        vm.assume(raLeft == 0);
+
+        vm.mockCall(address(SwapperMathLibrary), abi.encodeWithSelector(SwapperMathLibrary.calculateRolloverSale.selector), abi.encode(lvProfit, psmProfit, raLeft, dsReceived, lvReserveUsed, psmReserveUsed));
+
+        // After the seller's transfer of RA, the router has enough RA tokens to cover the profit
+        vm.assume(preState.routerRaBalance + amount >= psmProfit + lvProfit);
+
+        // Assuming that the router has enough DS to send to the seller
+        vm.assume(preState.routerDsBalance >= dsReceived);
+
+        // No overflow occurs in the PSM rollover profit accounting
+        vm.assume(preState.moduleCorePsmPoolArchiveRolloverProfit <= type(uint256).max - psmProfit - lvProfit);
+
+        // Assuming the reserves are sufficient 
+        vm.assume(preState.moduleCoreLvReserve >= lvReserveUsed);
+        vm.assume(preState.moduleCorePsmReserve >= psmReserveUsed);
+
+        // Assuming that the resulting `amountOut` of DS tokens the user will receive is sufficient
+        vm.assume(dsReceived >= amountOutMin); 
+
+        return (psmProfit, lvProfit, psmReserveUsed, lvReserveUsed);
+    }
+
+    function _assumeSwapDsForRaPreState(address seller, uint256 amount, uint256 amountOutMin) internal returns (uint256 sellerBalanceDs, uint256 routerBalanceDs) {
+        Pair memory pair = moduleCore.getPairInfo(id);
+        (address ds, address ct) = moduleCore.getDsCtPair(id);
+        uint256 dsId = moduleCore.getDsId(id);
+
+        address ra = pair.ra;
+    
+        // Assuming `amount` is are positive
+        vm.assume(amount > 0);
+
+        // Seller has symbolic amount of DS and RA
+        TestERC20(ra).setSymbolicBalanceOf(seller, "sellerRaBalance");        
+        TestAsset(ds).setSymbolicBalanceOf(seller, "sellerDsBalance");
+        TestAsset(ds).setSymbolicAllowance(seller, address(flashSwapRouter), "sellerRouterDsBalance");
+
+        sellerBalanceDs = TestAsset(ds).balanceOf(seller);
+        // Seller has enough DS to transfer `amount` to the router
+        vm.assume(sellerBalanceDs >= amount);
+        // Seller has granted a sufficient allowance of DS to the router
+        uint256 allowance = TestAsset(ds).allowance(seller, address(flashSwapRouter));
+        vm.assume(allowance >= amount);
+
+        // FlashSwapRouter has symbolic amount of DS and RA
+        TestAsset(ds).setSymbolicBalanceOf(address(flashSwapRouter), "routerDsBalance");
+        TestERC20(ra).setSymbolicBalanceOf(address(flashSwapRouter), "routerRaBalance");
+
+        // No overflow occurs during the transfer of DS to the router:
+        routerBalanceDs = TestAsset(ds).balanceOf(address(flashSwapRouter));
+        vm.assume(routerBalanceDs <= type(uint256).max - amount);
+
+        // Assuming that hiya is not 0 to prevent branching on its values,
+        // and that it is sufficiently small to not overflow
+        vm.assume(flashSwapRouter.getHiya(id) > 0);
+        vm.assume(flashSwapRouter.getHiyeCumulated(id) > 0);
+        vm.assume(flashSwapRouter.getHiyeCumulated(id) <= 1e8);
+        vm.assume(flashSwapRouter.getVhiyaCumulated(id) <= 1e8);
+
+        return (sellerBalanceDs, routerBalanceDs);
+    }
+
+    function _mockSwapDsForRaRouterCalls() internal {
+        // Mocking the `lvAcceptRolloverProfit` function; depositing into LV is covered by a separate proof
+        ModuleCoreMock mock = new ModuleCoreMock();
+        vm.mockFunction(
+            address(moduleCore), address(mock), abi.encodeWithSelector(ModuleCoreMock.lvAcceptRolloverProfit.selector)
+        );
+
+        // Mocking the result of hiya calculation with an arbitrary concrete value, assuming it doesn't overflow
+        vm.mockCall(address(SwapperMathLibrary), abi.encodeWithSelector(SwapperMathLibrary.calcHIYAaccumulated.selector), abi.encode(1));
+        vm.mockCall(address(SwapperMathLibrary), abi.encodeWithSelector(SwapperMathLibrary.calcVHIYAaccumulated.selector), abi.encode(1));
+    }
+
+    function test_swapRaForDs_rollover(uint256 amount, uint256 amountOutMin) public {
+        // Setting up a seller
+        address seller = address(0xABCDE);
+
+        // Setting up the hook;
+        hook.setFlashSwapRouter(address(flashSwapRouter));
+
+        // Assuming preconditions, defining mocks
+        _assumeSwapRaForDsPreState(seller, amount);
+        _stateSnapshotSwap(preState, seller);
+        (uint256 psmProfit, uint256 lvProfit, uint256 psmReserveUsed, uint256 lvReserveUsed) = _mockSwapRaForDsRouterCalls(amount, amountOutMin);
+
+        // Assuming that the rollover sale is possible
+        flashSwapRouter.assumeRollOverSale(id, moduleCore.getDsId(id));
+
+        // Calling `swapRaForDs` with symbolic values
+        vm.startPrank(seller);
+        uint256 amountReceived = flashSwapRouter.swapRaforDs(id, moduleCore.getDsId(id), amount, amountOutMin, IDsFlashSwapCore.BuyAprroxParams(256, 256, 1e16, 1e9, 1e9, 0.01 ether));
+        vm.stopPrank();
+
+        _stateSnapshotSwap(posState, seller);
+
+        // Checking resulting balances of user, router
+        assertEq(preState.sellerRaBalance - amount, posState.sellerRaBalance);
+        assertEq(preState.sellerDsBalance + amountReceived, posState.sellerDsBalance);
+        assertEq(preState.routerDsBalance - amountReceived, posState.routerDsBalance);
+        assertEq(preState.routerRaBalance + amount - (psmProfit + lvProfit), posState.routerRaBalance);
+        assertEq(preState.moduleCorePsmPoolArchiveRolloverProfit + psmProfit, posState.moduleCorePsmPoolArchiveRolloverProfit);
+        assertEq(preState.moduleCoreRaBalance + (psmProfit + lvProfit), posState.moduleCoreRaBalance);
+        assertEq(preState.moduleCorePsmReserve - psmReserveUsed, posState.moduleCorePsmReserve);
+        assertEq(preState.moduleCoreLvReserve - lvReserveUsed, posState.moduleCoreLvReserve);
+    }
+
+    function test_swapDsForRa(uint256 amount, uint256 amountOutMin) public {
+        // Setting up a seller
+        address seller = address(0xABCDE);
+        // Setting up the hook;
+        hook.setFlashSwapRouter(address(flashSwapRouter));
+        hook.isFlashSwap(true);
+
+        uint256 amountIn = freshUInt256Bounded();
+        hook.setAmountIn(amountIn);
+
+        // Assuming preconditions, defining mocks
+        (uint256 sellerBalanceDs, uint256 routerBalanceDs) = _assumeSwapDsForRaPreState(seller, amount, amountOutMin);
+        _stateSnapshotSwap(preState, seller);
+        _mockSwapDsForRaRouterCalls();
+
+        // Assuming that the amount of DS tokens transferred in by the user is greater than or equal to `amountIn` that should be provided to the hook
+        // If that is not the case, the execution will revert
+        vm.assume(amount >= amountIn);
+
+        // Expected received amount, as calculated in `SwapperMathLibrary.getAmountOutSellDs`, is sufficient:
+        uint256 amountReceivedExpected = amount - amountIn;
+        vm.assume(amountReceivedExpected >= amountOutMin);
+
+        // Calling `swapDsForRa` with symbolic values
+        vm.startPrank(seller);
+        uint256 amountReceived = flashSwapRouter.swapDsforRa(id, moduleCore.getDsId(id), amount, amountOutMin);
+        vm.stopPrank();
+        
+        _stateSnapshotSwap(posState, seller);
+
+        // Checking resulting balances of user, router
+        assertEq(amountReceivedExpected, amountReceived);
+        assertEq(preState.sellerRaBalance + amountReceived, posState.sellerRaBalance);
+        assertEq(preState.sellerDsBalance - amount, posState.sellerDsBalance);
+        assertEq(preState.routerRaBalance, posState.routerRaBalance);
+        /* TODO: CT, DS should be burned during the redemption */
+    }
+}
\ No newline at end of file
diff --git a/test/forge/kontrol/TestAsset.k.sol b/test/forge/kontrol/TestAsset.k.sol
new file mode 100644
index 0000000..1aed132
--- /dev/null
+++ b/test/forge/kontrol/TestAsset.k.sol
@@ -0,0 +1,133 @@
+// SPDX-License-Identifier: BUSL-1.1
+pragma solidity ^0.8.24;
+
+import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
+import {ERC20, ERC20Burnable} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
+import {IExpiry} from "../../../contracts/interfaces/IExpiry.sol";
+import {IRates} from "../../../contracts/interfaces/IRates.sol";
+import {CustomERC20Permit} from "../../../contracts/libraries/ERC/CustomERC20Permit.sol";
+
+import {KontrolTest} from "./KontrolTest.k.sol";
+import "./Constants.k.sol";
+
+/**
+ * @title Contract for Adding Exchange Rate functionality
+ * @author Cork Team
+ * @notice Adds Exchange Rate functionality to Assets contracts
+ */
+abstract contract ExchangeRate is IRates {
+    uint256 internal rate;
+
+    constructor(uint256 _rate) {
+        rate = _rate;
+    }
+
+    /**
+     * @notice returns the current exchange rate
+     */
+    function exchangeRate() external view override returns (uint256) {
+        return rate;
+    }
+}
+
+/**
+ * @title Contract for Adding Expiry functionality to DS
+ * @author Cork Team
+ * @notice Adds Expiry functionality to Assets contracts
+ * @dev Used for adding Expiry functionality to contracts like DS
+ */
+abstract contract Expiry is IExpiry {
+    uint256 internal EXPIRY;
+    uint256 internal ISSUED_AT;
+
+    constructor(uint256 _expiry) {
+        EXPIRY = _expiry;
+        ISSUED_AT = block.timestamp;
+    }
+
+    /**
+     * @notice returns if contract is expired or not(if timestamp==0 then contract not having any expiry)
+     */
+    function isExpired() external view virtual returns (bool) {
+        if (EXPIRY == 0) {
+            return false;
+        }
+
+        return block.timestamp >= EXPIRY;
+    }
+
+    /**
+     * @notice returns expiry timestamp of contract
+     */
+    function expiry() external view virtual returns (uint256) {
+        return EXPIRY;
+    }
+
+    function issuedAt() external view virtual returns (uint256) {
+        return ISSUED_AT;
+    }
+}
+
+/**
+ * @title Assets Contract
+ * @author Cork Team
+ * @notice Contract for implementing assets like DS/CT etc
+ */
+contract TestAsset is ERC20Burnable, Ownable, Expiry, ExchangeRate, KontrolTest {
+    uint256 internal DS_ID;
+
+    uint256 constant private _balancesSlot = 0;
+    uint256 constant private _allowancesSlot = 1;
+    uint256 constant private _totalSupplySlot = 2;
+
+    constructor(string memory name, string memory symbol, address _owner, uint256 _expiry, uint256 _rate, uint256 _dsId)
+        ExchangeRate(_rate)
+        ERC20(name, symbol)
+        Ownable(_owner)
+        Expiry(_expiry)
+    {
+        kevm.symbolicStorage(address(this));
+        DS_ID = _dsId;
+        EXPIRY = _expiry;
+        ISSUED_AT = block.timestamp;
+        rate = _rate;
+        //The ownerSlot of Asset is 8
+        uint256 _ownerSlot = 5;
+        vm.store(address(this), bytes32(_ownerSlot), bytes32(uint256(uint160(_owner))));
+        uint256 totalSupply = freshUInt256Bounded(string(abi.encodePacked(name,"totalSupply")));
+        vm.store(address(this), bytes32(_totalSupplySlot), bytes32(totalSupply));
+    }
+
+    /**
+     * @notice mints `amount` number of tokens to `to` address
+     * @param to address of receiver
+     * @param amount number of tokens to be minted
+     */
+    function mint(address to, uint256 amount) public onlyOwner {
+        _mint(to, amount);
+    }
+
+    /**
+     * @notice returns expiry timestamp of contract
+     */
+    function dsId() external view virtual returns (uint256) {
+        return DS_ID;
+    }
+
+    function updateRate(uint256 newRate) external override onlyOwner {
+        rate = newRate;
+    }
+
+    function setSymbolicBalanceOf(address account, string memory name) external {
+        uint256 balance = kevm.freshUInt(32, name);
+        vm.assume(balance <= totalSupply());
+        bytes32 balanceAccountSlot = keccak256(abi.encode(account, _balancesSlot));
+        vm.store(address(this), balanceAccountSlot, bytes32(balance));
+    }
+
+    function setSymbolicAllowance(address owner, address spender, string memory name) external {
+        uint256 allowance = freshUInt256Bounded(name);
+        bytes32 allowanceAccountSlot = keccak256(abi.encode(spender, keccak256(abi.encode(owner, _allowancesSlot))));
+        vm.store(address(this), allowanceAccountSlot, bytes32(allowance));
+    }
+}
diff --git a/test/forge/kontrol/TestAssetFactory.k.sol b/test/forge/kontrol/TestAssetFactory.k.sol
new file mode 100644
index 0000000..2ac6f5c
--- /dev/null
+++ b/test/forge/kontrol/TestAssetFactory.k.sol
@@ -0,0 +1,18 @@
+pragma solidity ^0.8.24;
+
+import {AssetFactory} from "../../../contracts/core/assets/AssetFactory.sol";
+
+import "forge-std/Test.sol";
+import {KontrolCheats} from "lib/kontrol-cheatcodes/src/KontrolCheats.sol";
+
+contract TestAssetFactory is AssetFactory, Test, KontrolCheats {
+
+    constructor() {
+        kevm.symbolicStorage(address(this));
+
+        bytes32 initializeSlot = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;
+
+        vm.store(address(this), initializeSlot, bytes32(0));
+    }
+
+}
\ No newline at end of file
diff --git a/test/forge/kontrol/TestCorkConfig.k.sol b/test/forge/kontrol/TestCorkConfig.k.sol
new file mode 100644
index 0000000..bc43870
--- /dev/null
+++ b/test/forge/kontrol/TestCorkConfig.k.sol
@@ -0,0 +1,24 @@
+pragma solidity ^0.8.24;
+
+import "../../../contracts/core/CorkConfig.sol";
+
+import "forge-std/Test.sol";
+import {KontrolCheats} from "lib/kontrol-cheatcodes/src/KontrolCheats.sol";
+
+/// @title TestFlashSwapRouter Contract, used for testing FlashSwapRouter contract, mostly here for getter functions
+contract TestCorkConfig is CorkConfig, Test, KontrolCheats {
+    
+    constructor() CorkConfig() {
+        kevm.symbolicStorage(address(this));
+
+        // _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
+        /* This role has been removed:
+        bytes32 hasAdminRoleSlot = keccak256(abi.encode(msg.sender, keccak256(abi.encode(DEFAULT_ADMIN_ROLE, uint256(0)))));
+        vm.store(address(this), hasAdminRoleSlot, bytes32(uint256(1)));
+        */
+
+        // _grantRole(MANAGER_ROLE, msg.sender);
+        bytes32 hasManagerRoleSlot = keccak256(abi.encode(msg.sender, keccak256(abi.encode(MANAGER_ROLE, uint256(0)))));
+        vm.store(address(this), hasManagerRoleSlot, bytes32(uint256(1)));
+    }
+}
\ No newline at end of file
diff --git a/test/forge/kontrol/TestCorkHook.k.sol b/test/forge/kontrol/TestCorkHook.k.sol
new file mode 100644
index 0000000..603eb77
--- /dev/null
+++ b/test/forge/kontrol/TestCorkHook.k.sol
@@ -0,0 +1,237 @@
+pragma solidity ^0.8.24;
+
+import {TestERC20} from "./TestERC20.t.sol";
+
+import "../../../contracts/core/CorkConfig.sol";
+
+import {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";
+import {ICorkHook} from "Cork-Hook/interfaces/ICorkHook.sol";
+import {MarketSnapshot} from "Cork-Hook/lib/MarketSnapshot.sol";
+import {SafeERC20, IERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
+import "v4-periphery/lib/v4-core/src/types/PoolKey.sol";
+import {TestAsset} from "./TestAsset.k.sol";
+import {TestFlashSwapRouter}     from "test/forge/kontrol/TestFlashSwapRouter.k.sol";
+
+import "forge-std/Test.sol";
+import {KontrolTest} from "./KontrolTest.k.sol";
+
+/// @title TestCorkHook Contract, used for testing CorkHook contract, mostly here for getter functions
+contract TestCorkHook is ICorkHook, Test, KontrolTest {
+    address lpBase;
+    address poolManager;
+
+    uint256 public raAdded;
+    uint256 public ctAdded;
+    uint256 public lpMinted;
+
+    uint256 private _amountOutMin;
+
+    bool private _isFlashSwap;
+    uint256 private _amountIn;
+    address private _flashSwapRouter;
+
+    struct CallbackData {
+        bool buyDs;
+        address caller;
+        // CT or RA amount borrowed
+        uint256 borrowed;
+        // DS or RA amount provided
+        uint256 provided;
+        // DS/RA amount attributed to user
+        uint256 attributed;
+        Id reserveId;
+        uint256 dsId;
+    }
+
+    constructor(address _poolManager, address _lpBase) {
+        kevm.symbolicStorage(address(this));
+
+        bytes32 initializeSlot = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;
+
+        vm.store(address(this), initializeSlot, bytes32(0));
+
+        lpBase = _lpBase;
+        poolManager = _poolManager;
+        raAdded = 0;
+        ctAdded = 0;
+        lpMinted = 0;
+
+        _flashSwapRouter = address(0);
+        _isFlashSwap = false;
+        _amountIn = 0;
+
+        /*
+        TODO: update:
+
+        // _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
+        bytes32 hasAdminRoleSlot = keccak256(abi.encode(msg.sender, keccak256(abi.encode(DEFAULT_ADMIN_ROLE, uint256(0)))));
+        vm.store(address(this), hasAdminRoleSlot, bytes32(uint256(1)));
+        
+        bytes32 hasManagerRoleSlot = keccak256(abi.encode(msg.sender, keccak256(abi.encode(MANAGER_ROLE, uint256(0)))));
+        vm.store(address(this), hasManagerRoleSlot, bytes32(0));
+        */
+    }
+
+    function setAmountIn(uint256 amountIn) public {
+        _amountIn = amountIn;
+    }
+
+    function setAmountOutMin(uint256 amountOutMin) public {
+        _amountOutMin = amountOutMin;
+    }
+
+    function isFlashSwap(bool isFlashSwapExecuted) public {
+        _isFlashSwap = isFlashSwapExecuted;
+    }
+
+    function setFlashSwapRouter(address flashSwapRouter) external {
+        _flashSwapRouter = flashSwapRouter;
+    }
+
+    function addLiquidity(
+        address ra,
+        address ct,
+        uint256 raAmount,
+        uint256 ctAmount,
+        uint256 amountRamin,
+        uint256 amountCtmin,
+        uint256 deadline
+    ) external returns (uint256 amountRa, uint256 amountCt, uint256 mintedLp) {
+        (amountRa, amountCt, mintedLp)  = 
+            (kevm.freshUInt(32, "amountRa"), kevm.freshUInt(32, "amountCt"), freshUInt256Bounded("mintedLp"));
+
+        vm.assume(amountRa <= raAmount);
+        vm.assume(amountCt <= ctAmount);
+        vm.assume(mintedLp <= IERC20(lpBase).totalSupply());
+
+        SafeERC20.safeTransferFrom(IERC20(ct), msg.sender, address(this), amountCt);
+
+        SafeERC20.safeTransferFrom(IERC20(ra), msg.sender, address(this), amountRa);
+        
+        // Mint LP
+        TestERC20(lpBase).mint(msg.sender, mintedLp);
+
+        // Save the variables
+        raAdded = amountRa;
+        ctAdded = amountCt;
+        lpMinted = mintedLp;
+    }
+
+    function swap(address ra, address ct, uint256 amountRaOut, uint256 amountCtOut, bytes calldata data)
+        external
+        returns (uint256 amountIn) {
+            if (_isFlashSwap) {
+                CallbackData memory callbackData = abi.decode(data, (CallbackData));
+
+                if (callbackData.buyDs) {
+                    uint256 actualRepaymentAmount = freshUInt256Bounded("actualRepaymentAmount");
+
+                    // hook has enough RA tokens for the flash loan
+                    vm.assume(amountRaOut <= TestERC20(ra).balanceOf(address(this)));
+                    // no overflow on the flash loan transfer of RA to the router
+                    unchecked {
+                        vm.assume(amountRaOut + TestERC20(ra).balanceOf(_flashSwapRouter) >= amountRaOut);
+                    }
+
+                    TestERC20(ra).transfer(_flashSwapRouter, amountRaOut);
+
+                    // mock for the flashSwapRouter callback
+                    TestFlashSwapRouter(_flashSwapRouter).CorkCallMockRaToDs(callbackData.reserveId, ra, address(this), callbackData.caller, actualRepaymentAmount, callbackData.attributed, amountRaOut, callbackData.provided, callbackData.dsId);            
+                    return actualRepaymentAmount;
+                } else {
+                    amountIn = _amountIn;
+
+                    // hook has enough CT tokens for the flash loan
+                    vm.assume(amountCtOut <= TestAsset(ct).balanceOf(address(this)));
+                    // no overflow on the flash loan transfer of CT to the router
+                    unchecked {
+                        vm.assume(amountCtOut + TestAsset(ct).balanceOf(_flashSwapRouter) >= amountCtOut);
+                    }
+
+                    TestAsset(ct).transfer(_flashSwapRouter, amountCtOut);
+
+                    // mock for the flashSwapRouter callback
+                    TestFlashSwapRouter(_flashSwapRouter).CorkCallMockDsToRa(callbackData.reserveId, ra, address(this), callbackData.caller, amountIn, callbackData.attributed, amountCtOut, callbackData.dsId);
+                    return amountIn;
+                }
+            } else {
+                return freshUInt256Bounded();
+            }
+        }
+
+    function removeLiquidity(
+        address ra,
+        address ct,
+        uint256 liquidityAmount,
+        uint256 amountRamin,
+        uint256 amountCtmin,
+        uint256 deadline
+    ) external returns (uint256 amountRa, uint256 amountCt) {
+        amountRa = freshUInt256Bounded("amountRa");
+        amountCt = freshUInt256Bounded("amountCt");
+
+        vm.assume(amountRa >= _amountOutMin);
+        vm.assume(amountRa <= IERC20(ra).balanceOf(address(this)));
+        vm.assume(amountCt <= IERC20(ct).balanceOf(address(this)));
+
+        IERC20(ct).transfer(msg.sender, amountCt);
+        IERC20(ra).transfer(msg.sender, amountRa);
+        TestERC20(lpBase).burnFrom(msg.sender, liquidityAmount);
+    }
+
+    function getLiquidityToken(address ra, address ct) external view returns (address) {
+        // WARNING: It returns lpBase for the purpose of the current tests is enough since lpbase is symbolic
+        return lpBase;
+    }
+
+    function getReserves(address ra, address ct) external view returns (uint256, uint256) {
+        return (freshUInt256Bounded(), freshUInt256Bounded());
+    }
+
+    function getFee(address ra, address ct)
+        external
+        view
+        returns (uint256 baseFeePercentage, uint256 actualFeePercentage) {
+            // TODO: Update constraints on fees
+            return (freshUInt256Bounded(), freshUInt256Bounded());
+        }
+
+    function getAmountIn(address ra, address ct, bool zeroForOne, uint256 amountOut)
+        external
+        view
+        returns (uint256 amountIn) {
+            if (_isFlashSwap) {
+                return _amountIn;
+            } else {
+                return freshUInt256Bounded();
+            }
+        }
+
+    function getAmountOut(address ra, address ct, bool zeroForOne, uint256 amountIn)
+        external
+        view
+        returns (uint256 amountOut){
+            return freshUInt256Bounded();
+        }
+
+    function getPoolManager() external view returns (address) {
+        // TODO: UPdate it once contract has a poolManager
+        return poolManager;
+    }
+
+    function getForwarder() external view returns (address) {
+         // TODO: UPdate it once contract has a forwarder
+        return freshAddress();
+    }
+
+    function getMarketSnapshot(address ra, address ct) external view returns (MarketSnapshot memory) {
+        // TODO: Make it more symbolic later
+        MarketSnapshot memory snapshot = MarketSnapshot(address(0), address(0), 0, 0, 0, 0, lpBase);
+        return snapshot;
+    }
+
+    function getPoolKey(address ra, address ct) external view returns (PoolKey memory) {
+
+    }
+
+}
\ No newline at end of file
diff --git a/test/forge/kontrol/TestERC20.t.sol b/test/forge/kontrol/TestERC20.t.sol
new file mode 100644
index 0000000..b240b45
--- /dev/null
+++ b/test/forge/kontrol/TestERC20.t.sol
@@ -0,0 +1,46 @@
+// SPDX-License-Identifier: UNLICENSED
+pragma solidity ^0.8.24;
+
+import {ERC20, ERC20Burnable} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
+
+import {KontrolTest} from "./KontrolTest.k.sol";
+
+/**
+ * @title DummyERCWithMetadata Contract
+ * @author Cork Team
+ * @notice Dummy contract which provides ERC20 with Metadata for RA & PA
+ */
+contract TestERC20 is ERC20Burnable, KontrolTest {
+
+    uint256 constant private _balancesSlot = 0;
+    uint256 constant private _allowancesSlot = 1;
+    uint256 constant private _totalSupplySlot = 2;
+
+    constructor(string memory name) ERC20(name, "TTK") {
+        kevm.symbolicStorage(address(this));
+        uint256 totalSupply = freshUInt256Bounded(string(abi.encodePacked(name,"totalSupply")));
+        vm.store(address(this), bytes32(_totalSupplySlot), bytes32(totalSupply));
+    }
+
+    function setSymbolicBalanceOf(address account, string memory name) external {
+        uint256 balance = kevm.freshUInt(32, name);
+        vm.assume(balance <= totalSupply());
+        bytes32 balanceAccountSlot = keccak256(abi.encode(account, _balancesSlot));
+        vm.store(address(this), balanceAccountSlot, bytes32(balance));
+    }
+
+    function setSymbolicAllowance(address owner, address spender, string memory name) external {
+        uint256 allowance = freshUInt256Bounded(name);
+        bytes32 allowanceAccountSlot = keccak256(abi.encode(spender, keccak256(abi.encode(owner, _allowancesSlot))));
+        vm.store(address(this), allowanceAccountSlot, bytes32(allowance));
+    }
+
+     /**
+     * @notice mints `amount` number of tokens to `to` address
+     * @param to address of receiver
+     * @param amount number of tokens to be minted
+     */
+    function mint(address to, uint256 amount) public {
+        _mint(to, amount);
+    }
+}
diff --git a/test/forge/kontrol/TestFlashSwapRouter.k.sol b/test/forge/kontrol/TestFlashSwapRouter.k.sol
new file mode 100644
index 0000000..526a743
--- /dev/null
+++ b/test/forge/kontrol/TestFlashSwapRouter.k.sol
@@ -0,0 +1,170 @@
+pragma solidity ^0.8.24;
+
+import "../../../contracts/core/flash-swaps/FlashSwapRouter.sol";
+
+import {KontrolTest} from "./KontrolTest.k.sol";
+import {TestERC20} from "./TestERC20.t.sol";
+import {TestAsset} from "./TestAsset.k.sol";
+import {TestModuleCore} from "./TestModuleCore.k.sol";
+
+/// @title TestFlashSwapRouter Contract, used for testing FlashSwapRouter contract, mostly here for getter functions
+contract TestFlashSwapRouter is RouterState, KontrolTest {
+
+    bytes32 constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;
+    
+    constructor(address config, address moduleCore) RouterState() {
+        kevm.symbolicStorage(address(this));
+
+        bytes32 initializeSlot = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;
+
+        vm.store(address(this), initializeSlot, bytes32(0));
+
+        bytes32 hasAdminRoleSlot = keccak256(abi.encode(msg.sender, keccak256(abi.encode(DEFAULT_ADMIN_ROLE, AccessControlStorageLocation))));
+        vm.store(address(this), hasAdminRoleSlot, bytes32(0));
+        
+        bytes32 hasConfigRoleSlot = keccak256(abi.encode(config, keccak256(abi.encode(CONFIG, AccessControlStorageLocation))));
+        vm.store(address(this), hasConfigRoleSlot, bytes32(0));
+
+        bytes32 hasModuleCoreRoleSlot = keccak256(abi.encode(moduleCore, keccak256(abi.encode(MODULE_CORE, AccessControlStorageLocation))));
+        vm.store(address(this), hasModuleCoreRoleSlot, bytes32(0));
+    }
+
+    function setSymbolicState(Id id, uint256 dsId, address ra, address ds, address ct, uint256 hyia) external {
+        reserves[id].hiya = hyia;
+        reserves[id].ds[dsId].ra = Asset(ra);
+        reserves[id].ds[dsId].ct = Asset(ct);
+        reserves[id].ds[dsId].ds = Asset(ds);
+        uint256 lvReserve = freshUInt256Bounded("lvReserve");
+        reserves[id].ds[dsId].lvReserve = lvReserve;
+        uint256 psmReserve = freshUInt256Bounded("psmReserve");
+        reserves[id].ds[dsId].psmReserve = psmReserve;
+    }
+
+    function assumeRollOverSale(Id id, uint256 dsId) external {
+        vm.assume(block.number <= reserves[id].rolloverEndInBlockNumber);
+        vm.assume(dsId > DsFlashSwaplibrary.FIRST_ISSUANCE);
+    }
+
+    // ------------------------------------------------------------ Getters ------------------------------ 
+    function getAssetPair(Id id,uint256 dsId) external view returns (AssetPair memory) {
+        return reserves[id].ds[dsId];
+    }
+
+    function getReserveSellPressurePercentage(Id id) external view returns (uint256) {
+        return reserves[id].reserveSellPressurePercentage;
+    }
+
+    function getHiyeCumulated(Id id) external view returns (uint256) {
+        return reserves[id].hiyaCumulated;
+    }
+
+    function getVhiyaCumulated(Id id) external view returns (uint256) {
+        return reserves[id].vhiyaCumulated;
+    }
+
+    function getDecayDiscountRateInDays(Id id) external view returns (uint256) {
+        return reserves[id].decayDiscountRateInDays;
+    }
+
+    function getRolloverEndInBlockNumber(Id id) external view returns (uint256) {
+        return reserves[id].rolloverEndInBlockNumber;
+    }
+
+    function getHiya(Id id) external view returns (uint256) {
+        return reserves[id].hiya;
+    }
+
+    // ------------------------------------------------------------ Auxiliary Mock Functions ------------------------------ 
+
+    function CorkCallMockDsToRa(Id reserveId, address ra, address hook, address caller, uint256 actualRepaymentAmount, uint256 attributed, uint256 borrowed, uint256 dsId) external {
+        AssetPair storage assetPair = reserves[reserveId].ds[dsId];
+
+        TestAsset(address(assetPair.ds)).approve(_moduleCore, attributed);
+        TestAsset(address(assetPair.ct)).approve(_moduleCore, attributed);
+
+        TestModuleCore psm = TestModuleCore(_moduleCore);
+
+        uint256 received = psm.mockRedeemRaWithCtDs(reserveId, borrowed);
+        // Assuming that the `received` RA from redeeming is sufficient to pay back the user 
+        vm.assume(received >= attributed);
+
+        uint256 repaymentAmount = received - attributed;
+        // Assuming the remaining `repaymentAmount` is sufficient to pay back the loan,
+        // for simplicity, assuming that they're equal and no dust is attributed to the user
+        vm.assume(repaymentAmount == actualRepaymentAmount);
+
+        if (actualRepaymentAmount > repaymentAmount) {
+            revert IMathError.InsufficientLiquidity();
+        } else if (actualRepaymentAmount < repaymentAmount) {
+            // refund excess
+            uint256 refunded = repaymentAmount - actualRepaymentAmount;
+            // assuming no overflow on adding `refunded` to attributed
+            unchecked {
+                vm.assume(attributed + refunded >= attributed);
+            }
+            attributed += refunded;
+        }
+
+        // Assuming the contract has enough tokens to transfer and no overflows occur
+        vm.assume(attributed <= type(uint256).max - actualRepaymentAmount);
+        vm.assume(TestERC20(ra).balanceOf(address(this)) >= actualRepaymentAmount + attributed);
+
+        // Sending the caller their RA
+        TestERC20(ra).transfer(caller, attributed);
+        // Repaying the flash loan
+        TestERC20(ra).transfer(hook, actualRepaymentAmount);
+    }
+
+    function CorkCallMockRaToDs(Id reserveId, address ra, address hook, address caller, uint256 actualRepaymentAmount, uint256 dsAttributed, uint256 borrowed, uint256 provided, uint256 dsId) external {
+        AssetPair storage assetPair = reserves[reserveId].ds[dsId];
+
+        uint256 deposited = provided + borrowed;
+
+        TestERC20(ra).approve(_moduleCore, deposited);
+
+        TestModuleCore psm = TestModuleCore(_moduleCore);
+        (uint256 received,) = psm.mockDepositPsm(reserveId, deposited);
+
+        // Assuming `received` is sufficient to pay back the user and repay flash loan, as implemented in the actual function
+        vm.assume(received >= dsAttributed - 1);
+        uint256 repaymentAmount = received - dsAttributed;
+        // Assuming the remaining `repaymentAmount` is sufficient to pay back the loan;
+        // for simplicity, assuming they're equal and no dust is attributed to the user
+        vm.assume(repaymentAmount == actualRepaymentAmount);
+
+        {
+            uint256 refunded;
+
+            // not enough liquidity
+            if (actualRepaymentAmount > received) {
+                revert IMathError.InsufficientLiquidity();
+            } else {
+                refunded = received - actualRepaymentAmount;
+                repaymentAmount = actualRepaymentAmount;
+            }
+
+            if (refunded > 0) {
+                // refund the user with extra ct
+                assetPair.ct.transfer(caller, refunded);
+            }
+        }
+
+        // for rounding error protection
+        dsAttributed -= 1;
+
+        assert(received >= dsAttributed);
+
+        // should be the same, we don't compare with the RA amount since we maybe dealing
+        // with a non-rebasing token, in which case the amount deposited and the amount received will always be different
+        // so we simply enforce that the amount received is equal to the amount attributed to the user
+
+        // Assuming the contract has enough tokens to transfer
+        vm.assume(TestAsset(address(assetPair.ds)).balanceOf(address(this)) >= received);
+        vm.assume(TestAsset(address(assetPair.ct)).balanceOf(address(this)) >= repaymentAmount);
+
+        // send caller their DS
+        assetPair.ds.transfer(caller, received);
+        // repay flash loan
+        assetPair.ct.transfer(hook, repaymentAmount);
+    }
+}
\ No newline at end of file
diff --git a/test/forge/kontrol/TestModuleCore.k.sol b/test/forge/kontrol/TestModuleCore.k.sol
new file mode 100644
index 0000000..45d1e19
--- /dev/null
+++ b/test/forge/kontrol/TestModuleCore.k.sol
@@ -0,0 +1,309 @@
+
+pragma solidity ^0.8.24;
+
+pragma solidity ^0.8.24;
+
+import {ModuleCore} from "../../../contracts/core/ModuleCore.sol";
+import {Withdrawal} from "../../../contracts/core/Withdrawal.sol";
+
+import {TestERC20} from "./TestERC20.t.sol";
+import {KontrolTest} from "./KontrolTest.k.sol";
+import {TestAsset} from "./TestAsset.k.sol";
+
+import {Id, Pair} from "../../../contracts/libraries/Pair.sol";
+import {
+    State,
+    PsmPoolArchive,
+    VaultState,
+    VaultAmmLiquidityPool,
+    Balances,
+    VaultConfig,
+    VaultBalances,
+    VaultWithdrawalPool
+} from "../../../contracts/libraries/State.sol";
+import {RedemptionAssetManager} from "../../../contracts/libraries/RedemptionAssetManagerLib.sol";
+import {BitMaps} from "@openzeppelin/contracts/utils/structs/BitMaps.sol";
+import {DepegSwap} from "../../../contracts/libraries/DepegSwapLib.sol";
+import {LvAsset} from "../../../contracts/libraries/LvAssetLib.sol";
+import {ICorkHook} from "Cork-Hook/interfaces/ICorkHook.sol";
+import {IDsFlashSwapCore} from "../../../contracts/interfaces/IDsFlashSwapRouter.sol";
+
+/// @title TestModuleCore Contract, used for testing ModuleCore contract, mostly here for getter functions
+contract TestModuleCore is ModuleCore, KontrolTest {
+    using BitMaps for BitMaps.BitMap;
+
+    constructor() ModuleCore() {
+        kevm.symbolicStorage(address(this));
+
+        bytes32 initializeSlot = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;
+
+        vm.store(address(this), initializeSlot, bytes32(0));
+    }
+
+    function withdrawalContract() public view returns (address) {
+        return WITHDRAWAL_CONTRACT;
+    }
+
+    // ------------------------------ GLOBAL GETTERS ------------------------------
+    function getDsId(Id id) external view returns (uint256) {
+        return states[id].globalAssetIdx;
+    }
+
+    function setSymbolicState(Id id, uint256 dsId, Pair memory key, address ds, address ct, address lv) external {
+        states[id].globalAssetIdx = dsId;
+
+        Withdrawal _withdrawalContract = new Withdrawal(address(0));
+        _setWithdrawalContract(address(_withdrawalContract));
+
+        setPairInfo(id, key);
+        setDsCtPair(id, dsId, ds, ct);
+        setSymbolicPsm(id);
+        setSymbolicVault(id, lv);
+    }
+
+    function setPairInfo(Id id, Pair memory key) internal {
+        states[id].info = key;
+        // WARNING: We will make expiryInterval concrete so it can info.toId() can be concrete
+        // Alternatively we can mockCalls to toId() so it returns the keccak with expiryInterval = 0
+    }
+
+    function getPairInfo(Id id) external view returns (Pair memory) {
+        return states[id].info;
+    }
+
+    function getDs(Id id, uint256 dsId) external view returns (DepegSwap memory) {
+        return states[id].ds[dsId];
+    }
+
+    function setDsCtSymbolicPair(Id id, uint256 dsId, address ds, address ct) external {
+        states[id].ds[dsId]._address = ds;
+        states[id].ds[dsId].ct = ct;
+    }
+    
+    function setDsCtPair(Id id, uint256 dsId, address ds, address ct) internal {
+        states[id].ds[dsId]._address = address(ds);
+        states[id].ds[dsId].ct = address(ct);
+        states[id].ds[dsId].expiredEventEmitted = kevm.freshBool();
+        uint256 ctRedeemed = freshUInt256Bounded("ctRedeemed");
+        states[id].ds[dsId].ctRedeemed = ctRedeemed;
+    }
+
+    function getDsCtPair(Id id) external view returns (address ds, address ct) {
+        uint256 dsId = states[id].globalAssetIdx;
+        ds = states[id].ds[dsId]._address;
+        ct = states[id].ds[dsId].ct;
+    }
+
+    function getIsInitialized(Id id) external view returns (bool) {
+        return states[id].info.pa != address(0) && states[id].info.ra != address(0);
+    }
+
+    function getDsIsInitialized(Id id, uint256 dsId) external view returns (bool) {
+        return states[id].ds[dsId]._address != address(0) && states[id].ds[dsId].ct != address(0);
+    }
+
+    function getDsIsExpired(Id id) external view returns (bool) {
+        uint256 dsId = states[id].globalAssetIdx;
+        return TestAsset(states[id].ds[dsId]._address).isExpired();
+    }
+    //--------------------------------------------------------------------------------
+
+    // ------------------------------ PSM GETTERS ------------------------------
+    function getPsmBalances(Id id) external view returns (Balances memory) {
+        return states[id].psm.balances;
+    }
+
+    function getPsmPoolArchiveRaAccrued(Id id, uint256 dsId) external view returns (uint256) {
+        return states[id].psm.poolArchive[dsId].raAccrued;
+    }
+
+    function getPsmPoolArchivePaAccrued(Id id, uint256 dsId) external view returns (uint256) {
+        return states[id].psm.poolArchive[dsId].paAccrued;
+    }
+
+    function getPsmPoolArchiveCtAttributed(Id id, uint256 dsId) external view returns (uint256) {
+        return states[id].psm.poolArchive[dsId].ctAttributed;
+    }
+
+    function getPsmPoolArchiveAttributedToRollover(Id id, uint256 dsId) external view returns (uint256) {
+        return states[id].psm.poolArchive[dsId].attributedToRolloverProfit;
+    }
+
+    function getPsmPoolArchiveRolloverClaims(Id id, uint256 dsId, address user) external view returns (uint256) {
+        return states[id].psm.poolArchive[dsId].rolloverClaims[user];
+    }
+
+    function getPsmPoolArchiveRolloverProfit(Id id, uint256 dsId) external view returns (uint256) {
+        return states[id].psm.poolArchive[dsId].rolloverProfit;
+    }
+
+    function getPsmRepurchaseFeePercentage(Id id) external view returns (uint256) {
+        return states[id].psm.repurchaseFeePercentage;
+    }
+
+    function getPsmBaseRedemptionFeePercentage(Id id) external view returns (uint256) {
+        return states[id].psm.psmBaseRedemptionFeePercentage;
+    }
+
+    function getPsmLiquiditySeparated(Id id, uint256 dsId) external view returns (bool) {
+        return states[id].psm.liquiditySeparated.get(dsId);
+    }
+
+    function getPsmIsDepositPaused(Id id) external view returns (bool) {
+        return states[id].psm.isDepositPaused;
+    }
+
+    function getPsmIsWithdrawalPaused(Id id) external view returns (bool) {
+        return states[id].psm.isWithdrawalPaused;
+    }
+
+    function setSymbolicPsm(Id id) internal {
+        Balances storage balances = states[id].psm.balances;
+        RedemptionAssetManager storage ra = balances.ra;
+        ra._address = states[id].info.ra;
+        ra.locked = freshUInt256Bounded("ra.locked");
+        ra.free = freshUInt256Bounded("ra.free");
+        balances.dsBalance = freshUInt256Bounded("balances.dsBalance");
+        balances.paBalance = freshUInt256Bounded("balances.paBalance");
+        balances.ctBalance = freshUInt256Bounded("balances.ctBalance");
+        uint256 psmBaseRedemptionFee = kevm.freshUInt(32, "psmBaseRedemptionFee");
+        vm.assume(psmBaseRedemptionFee < 5 ether);
+        states[id].psm.psmBaseRedemptionFeePercentage = psmBaseRedemptionFee;
+        states[id].psm.poolArchive[states[id].globalAssetIdx].rolloverProfit = freshUInt256Bounded("psm.rolloverProfit");
+        // ...
+    }
+    //--------------------------------------------------------------------------------
+
+    // ------------------------------ VAULT GETTERS ------------------------------
+    function getVaultBalances(Id id) external view returns (VaultBalances memory) {
+        return states[id].vault.balances;
+    }
+
+    function getVaultConfig(Id id) external view returns (VaultConfig memory) {
+        return states[id].vault.config;
+    }
+
+    function getVaultLvAsset(Id id) external view returns (LvAsset memory) {
+        return states[id].vault.lv;
+    }
+
+    function getVaultLpLiquidated(Id id, uint256 dsId) external view returns (bool) {
+        return states[id].vault.lpLiquidated.get(dsId);
+    }
+
+    function getVaultWithdrawalPool(Id id) external view returns (VaultWithdrawalPool memory) {
+        return states[id].vault.pool.withdrawalPool;
+    }
+
+    function getVaultAmmLiquidityPool(Id id) external view returns (VaultAmmLiquidityPool memory) {
+        return states[id].vault.pool.ammLiquidityPool;
+    }
+
+    function getWithdrawEligible(Id id, address user) external view returns (uint256) {
+        return states[id].vault.pool.withdrawEligible[user];
+    }
+
+    function getVaultIsDepositPaused(Id id) external view returns (bool) {
+        return states[id].vault.config.isDepositPaused;
+    }
+
+    function getVaultIsWithdrawalPaused(Id id) external view returns (bool) {
+        return states[id].vault.config.isWithdrawalPaused;
+    }
+
+    function getVaultCtHeldPercentage(Id id) external view returns (uint256) {
+        return states[id].vault.ctHeldPercetage;
+    }
+
+    function getVaultInitialized(Id id) external view returns (bool) {
+        return states[id].vault.initialized;
+    }
+
+    function setSymbolicVault(Id id, address lv) internal {
+        VaultState storage vault = states[id].vault;
+        vault.balances.ra._address = states[id].info.ra;
+        vault.balances.ctBalance = freshUInt256Bounded("vault.balances.ctBalance");
+
+        vault.lv._address = lv;
+        vault.lv.locked = freshUInt256Bounded("vault.lv.locked");
+
+        uint256 ctHeldPercentage = freshUInt256Bounded("ctHeldPercentage");
+        vm.assume(ctHeldPercentage >= 0.001 ether);
+        vm.assume(ctHeldPercentage <= 100 ether);
+        vault.ctHeldPercetage = ctHeldPercentage;
+        vault.initialized = kevm.freshBool();
+
+        uint256 lvFee = kevm.freshUInt(32, "lvFee");
+        vm.assume(lvFee < 5 ether);
+        vault.config.fee = lvFee;
+        
+        // ...
+    }
+    // ----------------------------UTILS-----------------------------------------------
+
+    function _assumeNewAddress(address freshAddress, Id id) external view {
+        vm.assume(freshAddress != states[id].info.ra);
+        vm.assume(freshAddress != states[id].info.pa);
+        
+        uint256 dsId = states[id].globalAssetIdx;
+        vm.assume(freshAddress != states[id].ds[dsId]._address);
+        vm.assume(freshAddress != states[id].ds[dsId].ct);
+    }
+
+    // ----------- AUXILIARY MOCK FUNCTION IMPLEMENTATIONS--------------------------------
+
+    function mockRedeemRaWithCtDs(Id id, uint256 amount) external returns (uint256 ra) {
+        /* A more extensive version of the mock & proof should check whether 
+            - CT & DS tokens got burned
+            - the `locked` variable is updated correctly
+            - withdrawals are not paused
+
+            For example, 
+
+            ra = amount;
+            self.psm.balances.ra.unlockTo(owner, ra);
+            ERC20Burnable(ds.ct).burnFrom(owner, amount);
+            ERC20Burnable(ds._address).burnFrom(owner, amount);
+        */
+
+        address _ra = states[id].info.ra;
+
+        uint256 received = freshUInt256("received_from_redeem");
+        // Assuming no overflow occurs on transfer to the caller
+        unchecked {
+            vm.assume(TestERC20(_ra).balanceOf(msg.sender) + received >= received);
+        }
+        // Assuming this contract has enough tokens to transfer
+        vm.assume(TestERC20(_ra).balanceOf(address(this)) >= received);
+
+        TestERC20(_ra).transfer(msg.sender, received);
+
+        return received;
+    }
+
+    function mockDepositPsm(Id id, uint256 amount) external returns (uint256 received, uint256 exchangeRate) {
+        /* A more extensive version of the mock & proof should check whether 
+            - deposits are not paused
+            - ds has not expired
+            - exchangeRate is actually 1
+        */
+
+        State storage state = states[id];
+        DepegSwap storage ds = state.ds[state.globalAssetIdx];
+
+        received = amount;
+
+        /* TODO:
+        state.psm.balances.ra.lockFrom(amount, msg.sender);
+        ds.issue(msg.sender, received);
+        */
+
+        // Assuming that no overflows occur during `mint`
+        unchecked {
+            vm.assume(TestERC20(ds._address).balanceOf(msg.sender) + received >= received);
+            vm.assume(TestERC20(ds.ct).balanceOf(msg.sender) + received >= received);
+        }
+
+        return (received, 1);
+    }
+}
